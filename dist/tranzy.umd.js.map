{"version":3,"file":"tranzy.umd.js","sources":["../src/tranzy.js"],"sourcesContent":["/**\n * Tranzy - 网页自动翻译插件\n * 支持自动检测DOM更新并翻译新增元素\n * 使用微软翻译API实现多语言翻译\n * 同时支持ESM和浏览器直接使用\n *\n * @author Tranzy\n * @license MIT\n */\n\n// 默认忽略的选择器列表，这些元素及其内容不会被翻译\nconst DEFAULT_IGNORE_SELECTORS = [\n  'script',           // 脚本标签\n  'style',            // 样式标签\n  'noscript',         // 无脚本标签\n  'code',             // 代码标签\n  'pre',              // 预格式化文本标签\n  'input',            // 输入框\n  'textarea',         // 文本域\n  '[contenteditable=\"true\"]', // 可编辑元素\n  '.tranzy-ignore'    // 自定义忽略类\n];\n\n// 默认配置选项\nconst DEFAULT_CONFIG = {\n  toLang: navigator.language || '',    // 目标语言，默认从浏览器语言设置获取，如果没有则使用中文\n  fromLang: '',                        // 源语言，如：'en'\n  root: 'body',                        // 要翻译的根元素\n  ignore: [],                          // 自定义忽略选择器列表\n  force: [],                           // 强制翻译选择器列表\n  doneClass: 'tranzy-done',            // 已翻译元素的标记类\n  pendingClass: 'tranzy-pending',      // 正在翻译中的元素标记类\n  auto: false,                         // 是否自动监听DOM变化\n  batch: 100,                          // 批量翻译时的批次大小\n  translator: null,                    // 自定义翻译器实例\n  manualDict: {},                      // 手动翻译词典\n  hooks: {                             // 生命周期钩子函数\n    before: null,                      // 翻译开始前的钩子\n    after: null,                       // 翻译结束后的钩子\n    beforeElement: null,               // 翻译单个元素前的钩子\n    afterElement: null,                // 翻译单个元素后的钩子\n  }\n};\n\n// 辅助函数：深度合并对象，支持数组去重\nfunction mergeDeep(...objects) {\n  return objects.reduce((prev, obj) => {\n    Object.keys(obj).forEach(key => {\n      const pVal = prev[key];\n      const oVal = obj[key];\n\n      if (Array.isArray(pVal) && Array.isArray(oVal)) {\n        // 数组类型进行合并并去重\n        prev[key] = Array.from(new Set([...pVal, ...oVal]));\n      } else if (isObject(pVal) && isObject(oVal)) {\n        // 对象类型进行递归合并\n        prev[key] = mergeDeep(pVal, oVal);\n      } else {\n        // 其他类型直接覆盖\n        prev[key] = oVal;\n      }\n    });\n\n    return prev;\n  }, {});\n}\n\n// 辅助函数：检查值是否为对象（非null且非数组）\nfunction isObject(item) {\n  return (item && typeof item === 'object' && !Array.isArray(item));\n}\n\n// IndexedDB缓存管理器：用于存储翻译结果，提高性能\nclass TranslationCache {\n  constructor() {\n    this.dbName = 'tranzy-cache';      // 数据库名称\n    this.storeName = 'translations';    // 存储对象名称\n    this.db = null;                     // 数据库实例\n    this.initPromise = this._initDatabase(); // 初始化Promise\n  }\n\n  // 生成字符串哈希值，用于缓存键\n  _generateHash(str) {\n    let hash = 2166136261;\n    for (let i = 0; i < str.length; i++) {\n      hash ^= str.charCodeAt(i);\n      hash *= 16777619;\n    }\n    return hash.toString(36);  // 使用base36编码，生成更短的哈希值\n  }\n\n  // 初始化IndexedDB数据库\n  async _initDatabase() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, 1);\n\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          const store = db.createObjectStore(this.storeName, { keyPath: 'id' });\n        }\n      };\n\n      request.onsuccess = (event) => {\n        this.db = event.target.result;\n        resolve();\n      };\n\n      request.onerror = (event) => {\n        console.error('Tranzy: 初始化缓存数据库失败', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  }\n\n  // 获取缓存的翻译结果\n  async get(text, toLang, fromLang = '') {\n    await this.initPromise;\n    const id = this._generateHash(`${text}|${toLang}|${fromLang}`);\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve(null);\n        return;\n      }\n\n      const transaction = this.db.transaction(this.storeName, 'readonly');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.get(id);\n\n      request.onsuccess = (event) => {\n        resolve(event.target.result?.value || null);\n      };\n\n      request.onerror = () => {\n        resolve(null);\n      };\n    });\n  }\n\n  // 设置翻译结果到缓存\n  async set(text, translation, toLang, fromLang = '') {\n    await this.initPromise;\n    const id = this._generateHash(`${text}|${toLang}|${fromLang}`);\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve();\n        return;\n      }\n\n      const transaction = this.db.transaction(this.storeName, 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.put({\n        id,\n        value: translation\n      });\n\n      request.onsuccess = () => {\n        resolve();\n      };\n\n      request.onerror = () => {\n        resolve();\n      };\n    });\n  }\n\n  // 批量获取缓存的翻译结果\n  async getBatch(texts, toLang, fromLang = '') {\n    await this.initPromise;\n    const results = Array(texts.length).fill(null);\n    const remainingIndices = [];\n\n    await Promise.all(texts.map(async (text, index) => {\n      const cachedTranslation = await this.get(text, toLang, fromLang);\n      if (cachedTranslation) {\n        results[index] = cachedTranslation;\n      } else {\n        remainingIndices.push(index);\n      }\n    }));\n\n    return {\n      results,\n      remainingIndices\n    };\n  }\n\n  // 批量设置翻译结果到缓存\n  async setBatch(texts, translations, toLang, fromLang = '') {\n    await this.initPromise;\n    await Promise.all(texts.map((text, index) => {\n      return this.set(text, translations[index], toLang, fromLang);\n    }));\n  }\n}\n\n// 默认微软翻译API实现\nclass MicrosoftTranslator {\n  constructor(fromLang = '') {\n    this.fromLang = fromLang;\n    this.tokenExpireMinutes = 10; // token过期时间（分钟）\n    this._loadTokenFromSession();\n  }\n\n  // 从sessionStorage加载token\n  _loadTokenFromSession() {\n    try {\n      const tokenData = sessionStorage.getItem('tranzy_auth_token');\n      if (tokenData) {\n        const { token, timestamp } = JSON.parse(tokenData);\n        const now = Date.now();\n        // 如果token未过期，则使用缓存的token\n        if (token && (now - timestamp) < this.tokenExpireMinutes * 60 * 1000) {\n          this.authToken = token;\n          this.tokenTimestamp = timestamp;\n        } else {\n          // token已过期，清除缓存\n          this._clearTokenFromSession();\n        }\n      }\n    } catch (error) {\n      console.error('Tranzy: 从session加载token失败', error);\n      this._clearTokenFromSession();\n    }\n  }\n\n  // 保存token到sessionStorage\n  _saveTokenToSession(token, timestamp) {\n    try {\n      sessionStorage.setItem('tranzy_auth_token', JSON.stringify({ token, timestamp }));\n    } catch (error) {\n      console.error('Tranzy: 保存token到session失败', error);\n    }\n  }\n\n  // 清除sessionStorage中的token\n  _clearTokenFromSession() {\n    try {\n      sessionStorage.removeItem('tranzy_auth_token');\n      this.authToken = null;\n      this.tokenTimestamp = 0;\n    } catch (error) {\n      console.error('Tranzy: 清除session中的token失败', error);\n    }\n  }\n\n  // 获取微软翻译API的认证token\n  async getAuthToken() {\n    const now = Date.now();\n\n    // 如果token获取时间小于10分钟，则直接返回\n    if (this.authToken && (now - this.tokenTimestamp) < this.tokenExpireMinutes * 60 * 1000) {\n      return this.authToken;\n    }\n\n    try {\n      const response = await fetch('https://edge.microsoft.com/translate/auth', {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`获取微软翻译授权失败: ${response.status} ${response.statusText}`);\n      }\n\n      const token = await response.text();\n      this.tokenTimestamp = now;\n      this.authToken = token;\n      \n      // 保存token到session\n      this._saveTokenToSession(token, now);\n      \n      return token;\n    } catch (error) {\n      console.error('Tranzy: 获取微软翻译授权失败', error);\n      this._clearTokenFromSession();\n      throw error;\n    }\n  }\n\n  // 调用微软翻译API进行翻译\n  async translate(texts, toLang) {\n    try {\n      // 过滤掉空文本和null值\n      const filteredTexts = texts.filter(text => text && text.trim());\n\n      // 如果没有有效文本需要翻译，直接返回空数组\n      if (filteredTexts.length === 0) {\n        return [];\n      }\n\n      // 获取认证令牌\n      const token = await this.getAuthToken();\n\n      // 构建URL，只在设置了fromLang时添加from参数\n      const url = `https://api.cognitive.microsofttranslator.com/translate?${this.fromLang?`from=${this.fromLang}&`:''}&to=${toLang}&api-version=3.0`\n        \n\n      // 构建请求数据\n      const data = filteredTexts.map(text => ({ Text: text }));\n\n      // 发送请求\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify(data)\n      });\n\n      if (!response.ok) {\n        throw new Error(`翻译请求失败: ${response.status} ${response.statusText}`);\n      }\n\n      // 处理响应\n      const result = await response.json();\n      return result.map(item => item.translations[0].text);\n    } catch (error) {\n      console.error('Tranzy: 翻译请求失败', error);\n      throw error;\n    }\n  }\n}\n\n// Tranzy核心类\nclass Tranzy {\n  constructor(config = {}) {\n    // 合并默认配置与用户配置\n    this.config = mergeDeep({}, DEFAULT_CONFIG, config);\n\n    // 标准化manualDict配置\n    if (this.config.manualDict) {\n      Object.keys(this.config.manualDict).forEach(lang => {\n        const langDict = this.config.manualDict[lang];\n        Object.keys(langDict).forEach(term => {\n          // 如果翻译值是字符串，转换为标准格式\n          if (typeof langDict[term] === 'string') {\n            langDict[term] = {\n              to: langDict[term],\n              standalone: true,\n              case: true\n            };\n          }\n        });\n      });\n    }\n\n    // 初始化缓存\n    this.cache = new TranslationCache();\n\n    // 初始化翻译器，传入用户配置的fromLang\n    this.translator = this.config.translator || new MicrosoftTranslator(this.config.fromLang);\n\n    // 初始化状态\n    this.isTranslating = false;         // 是否正在翻译\n    this.pendingElements = new Set();   // 待翻译元素集合\n    this.observer = null;               // DOM观察器实例\n    this.observerConfig = {             // 观察器配置\n      childList: true,                  // 观察子节点变化\n      subtree: true                     // 观察后代节点变化\n    };\n  }\n\n  // 初始化插件\n  init() {\n    // 合并并去重忽略选择器\n    this.config.ignore = [...new Set([\n      ...DEFAULT_IGNORE_SELECTORS,\n      ...(this.config.ignore || [])\n    ])];\n\n    // 确保强制翻译选择器是数组\n    this.config.force = this.config.force || [];\n\n    // 先进行一次初始翻译\n    this.translatePage();\n\n    // 如果配置了自动监听，则开始监听DOM变化\n    if (this.config.auto) {\n      this.startObserver();\n    }\n\n    return this;\n  }\n\n  // 开始观察DOM变化\n  startObserver() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n\n    this.observer = new MutationObserver((mutations) => {\n      let shouldTranslate = false;\n      for (const mutation of mutations) {\n        // 处理新增节点\n        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n          mutation.addedNodes.forEach(node => {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n              // 使用TreeWalker遍历所有元素节点\n              const treeWalker = document.createTreeWalker(\n                node,\n                NodeFilter.SHOW_ELEMENT,\n                {\n                  acceptNode: function (node) {\n                    // 如果元素匹配任何强制翻译选择器，则始终接受\n                    if (this.config.force.some(selector => node.matches(selector))) {\n                      return NodeFilter.FILTER_ACCEPT;\n                    }\n\n                    // 跳过被忽略的元素及其所有子元素\n                    if (this.config.ignore.some(selector => node.matches(selector))) {\n                      return NodeFilter.FILTER_REJECT;\n                    }\n                    return NodeFilter.FILTER_ACCEPT;\n                  }.bind(this)\n                }\n              );\n\n              // 检查根节点是否应该被处理\n              if (this.config.ignore.some(selector => node.matches(selector)) &&\n                !this.config.force.some(selector => node.matches(selector))) {\n                return; // 如果根节点被忽略且不在强制翻译列表中，直接跳过整个树\n              }\n\n              // 添加根节点\n              this.pendingElements.add(node);\n              shouldTranslate = true;\n\n              // 添加所有子元素节点\n              let currentNode;\n              while (currentNode = treeWalker.nextNode()) {\n                this.pendingElements.add(currentNode);\n              }\n            }\n          });\n        }\n\n        // 处理文本变化\n        if (mutation.type === 'characterData') {\n          const node = mutation.target.parentNode;\n          if (node && node.nodeType === Node.ELEMENT_NODE) {\n            // 检查所有父元素，如果有任何父元素被忽略且不在强制翻译列表中，则跳过\n            let shouldSkip = false;\n            let parent = node;\n\n            while (parent) {\n              if (this.config.ignore.some(selector => parent.matches(selector)) &&\n                !this.config.force.some(selector => parent.matches(selector))) {\n                shouldSkip = true;\n                break;\n              }\n              parent = parent.parentNode;\n              if (!parent || parent === document) break;\n            }\n\n            if (!shouldSkip) {\n              this.pendingElements.add(node);\n              shouldTranslate = true;\n            }\n          }\n        }\n      }\n\n      if (shouldTranslate) {\n        // 直接翻译\n        this._translatePending();\n      }\n    });\n\n    this.observer.observe(document.body, this.observerConfig);\n\n    return this;\n  }\n\n  // 停止观察DOM变化\n  stopObserver() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n\n    return this;\n  }\n\n  // 翻译待处理元素\n  async _translatePending() {\n    if (this.pendingElements.size === 0 || this.isTranslating) {\n      return;\n    }\n\n    this.isTranslating = true;\n\n    const elements = Array.from(this.pendingElements);\n    this.pendingElements.clear();\n\n    await this._translateElements(elements);\n\n    this.isTranslating = false;\n\n    // 检查是否有新的待处理元素\n    if (this.pendingElements.size > 0) {\n      this._translatePending();\n    }\n  }\n\n  // 翻译整个页面\n  async translatePage() {\n    if (this.isTranslating) {\n      return;\n    }\n\n    this.isTranslating = true;\n\n    // 临时停止观察器，避免翻译过程中触发更多的变化\n    const wasObserving = !!this.observer;\n    if (wasObserving) {\n      this.stopObserver();\n    }\n\n    // 执行beforeTranslate钩子\n    if (typeof this.config.hooks.before === 'function') {\n      await this.config.hooks.before();\n    }\n\n    try {\n      // 使用TreeWalker获取所有需要翻译的元素\n      const elements = [];\n      const rootElement = document.querySelector(this.config.root);\n\n      // 创建TreeWalker，只显示元素节点\n      const treeWalker = document.createTreeWalker(\n        rootElement,\n        NodeFilter.SHOW_ELEMENT,\n        {\n          acceptNode: function (node) {\n            // 跳过已翻译的元素\n            if (node.classList.contains(this.config.doneClass)) {\n              return NodeFilter.FILTER_SKIP; // 改为SKIP，允许检查子元素\n            }\n\n            // 跳过被忽略的元素及其所有子元素\n            if (node.matches(this.config.ignore)) {\n              // 如果元素匹配强制翻译选择器，允许翻译该元素\n              if (this.config.force.some(selector => node.matches(selector))) {\n                return NodeFilter.FILTER_ACCEPT;\n              }\n              return NodeFilter.FILTER_REJECT; // 忽略此元素及其所有子元素\n            }\n\n            // 如果元素匹配强制翻译选择器，则始终接受\n            if (this.config.force.some(selector => node.matches(selector))) {\n              return NodeFilter.FILTER_ACCEPT;\n            }\n\n            return NodeFilter.FILTER_ACCEPT;\n          }.bind(this)\n        }\n      );\n\n      // 收集所有符合条件的元素\n      let node;\n      while (node = treeWalker.nextNode()) {\n        elements.push(node);\n      }\n\n      await this._translateElements(elements);\n    } catch (error) {\n      console.error('Tranzy: 页面翻译失败', error);\n    } finally {\n      // 执行afterTranslate钩子\n      if (typeof this.config.hooks.after === 'function') {\n        await this.config.hooks.after();\n      }\n\n      this.isTranslating = false;\n\n      // 如果之前在观察，重新启动观察器\n      if (wasObserving) {\n        this.startObserver();\n      }\n    }\n\n    return this;\n  }\n\n  // 翻译元素数组\n  async _translateElements(elements) {\n    // 过滤出需要翻译的元素\n    const validElements = elements.filter(el => {\n      // 跳过已经翻译过的元素\n      if (el.classList.contains(this.config.doneClass)) {\n        return false;\n      }\n\n      // 如果元素匹配强制翻译选择器，则始终翻译\n      if (this.config.force.some(selector => el.matches(selector))) {\n        return true;\n      }\n\n      // 检查所有父元素是否被忽略\n      let parent = el.parentNode;\n      while (parent && parent !== document) {\n        if (parent.matches(this.config.ignore)) {\n          return false; // 如果任何父元素被忽略且不在强制翻译列表中，则忽略此元素\n        }\n        parent = parent.parentNode;\n      }\n\n      // 跳过被忽略的元素\n      if (el.matches(this.config.ignore)) {\n        return false;\n      }\n\n      // 跳过没有文本内容的元素\n      const text = this._getElementText(el);\n\n      return text && text.trim().length > 0;\n    });\n\n    if (validElements.length === 0) {\n      return;\n    }\n\n    // 批量处理元素\n    const batchSize = this.config.batch;\n    for (let i = 0; i < validElements.length; i += batchSize) {\n      const batch = validElements.slice(i, i + batchSize);\n      await this._translateElementBatch(batch);\n    }\n  }\n\n  // 检查文本中是否包含术语并拆分\n  _splitByTerms(text) {\n    const toLangDict = this.config.manualDict[this.config.toLang];\n    if (!toLangDict) return [text];\n\n    // 按长度降序排序术语，优先匹配最长的术语\n    const terms = Object.keys(toLangDict).sort((a, b) => b.length - a.length);\n    \n    // 先检查是否有完全匹配的术语\n    for (const term of terms) {\n      const translation = toLangDict[term];\n      // 如果是独立匹配模式（默认为true）且文本完全等于术语\n      if ((translation.standalone !== false) && \n          (translation.case === false ? text.toLowerCase() === term.toLowerCase() : text === term)) {\n        return [text];\n      }\n    }\n\n    // 如果没有完全匹配，且文本中没有包含任何术语，直接返回原文本\n    if (!terms.some(term => {\n      const translation = toLangDict[term];\n      return translation.case === false ? \n        text.toLowerCase().includes(term.toLowerCase()) : \n        text.includes(term);\n    })) {\n      return [text];\n    }\n\n    // 拆分文本\n    const parts = [];\n    let currentText = text;\n    let lastIndex = 0;\n\n    while (currentText.length > 0) {\n      let foundTerm = false;\n      for (const term of terms) {\n        const translation = toLangDict[term];\n        // 跳过需要独立匹配的术语\n        if (translation.standalone !== false) {\n          continue;\n        }\n\n        // 使用正则表达式匹配术语，根据case配置决定是否忽略大小写\n        const flags = translation.case === false ? 'gi' : 'g';\n        const termRegex = new RegExp(`\\\\b${term}\\\\b`, flags);\n        const match = termRegex.exec(currentText);\n        \n        if (match) {\n          const index = match.index;\n          // 如果术语前面有文本，添加为一部分\n          if (index > 0) {\n            parts.push(currentText.substring(0, index));\n          }\n          // 添加术语\n          parts.push(term);\n          // 更新剩余文本\n          currentText = currentText.substring(index + term.length);\n          foundTerm = true;\n          break;\n        }\n      }\n      // 如果没有找到术语，将剩余文本作为一部分\n      if (!foundTerm) {\n        parts.push(currentText);\n        break;\n      }\n    }\n\n    return parts;\n  }\n\n  // 批量翻译元素\n  async _translateElementBatch(elements) {\n    // 收集需要翻译的文本\n    const elementsWithText = [];\n    let textsToTranslate = [];\n\n    for (const element of elements) {\n      // 执行beforeElementTranslate钩子\n      if (typeof this.config.hooks.beforeElement === 'function') {\n        const shouldContinue = await this.config.hooks.beforeElement(element);\n        if (shouldContinue === false) {\n          continue;\n        }\n      }\n\n      const text = this._getElementText(element);\n      if (text && text.trim().length > 0) {\n        // 简单的内容过滤，忽略纯数字、纯特殊字符等内容\n        if (this._shouldTranslateText(text)) {\n          elementsWithText.push(element);\n          textsToTranslate.push(text);\n          // 添加正在翻译的class\n          element.classList.add(this.config.pendingClass);\n        }\n      }\n    }\n\n    if (textsToTranslate.length === 0) {\n      return;\n    }\n\n    // 创建翻译结果映射表\n    const translationMap = {};\n    const termPartsMap = {}; // 记录需要按术语拆分的文本\n    const textsToCheckCache = [];\n    const finalTextsToFetch = new Set();\n\n    // 收集所有需要翻译的文本\n    for (const text of textsToTranslate) {\n      // 检查文本中是否包含术语\n      const parts = this._splitByTerms(text);\n      \n      // 如果只有一个部分，说明没有术语，直接检查完整文本\n      if (parts.length === 1) {\n        const toLangDict = this.config.manualDict[this.config.toLang];\n        // 根据case设置决定如何匹配\n        const translation = toLangDict && (\n          toLangDict[text] || // 直接匹配\n          (toLangDict[text.toLowerCase()]?.case === false ? toLangDict[text.toLowerCase()] : null) // 忽略大小写匹配\n        );\n        \n        if (translation) {\n          translationMap[text] = translation.to;\n        } else {\n          textsToCheckCache.push(text);\n        }\n      } else {\n        // 如果有多个部分，记录需要按术语拆分的文本\n        termPartsMap[text] = parts;\n        // 将拆分出的部分添加到待翻译列表\n        for (const part of parts) {\n          const toLangDict = this.config.manualDict[this.config.toLang];\n          // 根据case设置决定如何匹配\n          const translation = toLangDict && (\n            toLangDict[part] || // 直接匹配\n            (toLangDict[part.toLowerCase()]?.case === false ? toLangDict[part.toLowerCase()] : null) // 忽略大小写匹配\n          );\n          \n          if (translation) {\n            translationMap[part] = translation.to;\n          } else {\n            const cachedTranslation = await this.cache.get(part, this.config.toLang, this.config.fromLang);\n            if (cachedTranslation) {\n              translationMap[part] = cachedTranslation;\n            } else {\n              finalTextsToFetch.add(part);\n            }\n          }\n        }\n      }\n    }\n\n    // 检查缓存（只检查未找到手动翻译的文本）\n    const { results: cacheResults, remainingIndices: remainingIndices } =\n      await this.cache.getBatch(textsToCheckCache, this.config.toLang, this.config.fromLang);\n\n    // 将缓存结果合并到翻译映射表中\n    let cacheIndex = 0;\n    textsToCheckCache.forEach(text => {\n      if (!(text in translationMap)) {\n        translationMap[text] = cacheResults[cacheIndex++];\n      }\n    });\n\n    // 收集需要调用API的文本\n    remainingIndices.forEach(index => {\n      finalTextsToFetch.add(textsToCheckCache[index]);\n    });\n\n    // 获取API翻译\n    if (finalTextsToFetch.size > 0) {\n      try {\n        // 二次过滤不需要翻译的内容\n        const filteredTexts = Array.from(finalTextsToFetch).filter(text => this._shouldTranslateText(text));\n        \n        // 将不需要翻译的文本直接设置为原文本\n        Array.from(finalTextsToFetch).forEach(text => {\n          if (!filteredTexts.includes(text)) {\n            translationMap[text] = text;\n          }\n        });\n\n        // 添加日志，帮助调试重复调用问题\n        console.log('Tranzy: 调用API翻译', filteredTexts.length, '个文本');\n\n        if (filteredTexts.length > 0) {\n          const apiResults = await this.translator.translate(filteredTexts, this.config.toLang);\n\n          // 将API翻译结果写入缓存\n          await this.cache.setBatch(filteredTexts, apiResults, this.config.toLang, this.config.fromLang);\n\n          // 将API结果合并到翻译映射表中\n          let apiIndex = 0;\n          filteredTexts.forEach(text => {\n            translationMap[text] = apiResults[apiIndex++];\n          });\n        }\n      } catch (error) {\n        console.error('Tranzy: 批量翻译失败', error);\n        Array.from(finalTextsToFetch).forEach(text => {\n          translationMap[text] = text; // 发生错误时保持原文本\n        });\n      }\n    }\n\n    // 合并术语翻译结果\n    for (const [originalText, parts] of Object.entries(termPartsMap)) {\n      const translatedParts = parts.map(part => translationMap[part] || part);\n      translationMap[originalText] = translatedParts.join('');\n    }\n\n    // 应用翻译\n    elementsWithText.forEach((element, index) => {\n      const originalText = textsToTranslate[index];\n      const translatedText = translationMap[originalText];\n\n      if (translatedText) {\n        // 移除正在翻译的class\n        element.classList.remove(this.config.pendingClass);\n        this._applyTranslation(element, originalText, translatedText);\n\n        // 执行afterElementTranslate钩子\n        if (typeof this.config.hooks.afterElement === 'function') {\n          this.config.hooks.afterElement(element, originalText, translatedText);\n        }\n      }\n    });\n  }\n\n  // 判断文本是否值得翻译（过滤掉纯数字、纯符号等内容）\n  _shouldTranslateText(text) {\n    // 过滤掉空文本或只包含空白字符的文本\n    if (!text || /^\\s*$/.test(text)) {\n      return false;\n    }\n\n    // 过滤掉只包含数字、空格、回车、特殊字符的文本\n    // 但保留包含中文、英文、数字的文本\n    if (/^[\\s\\d\\p{P}\\p{S}]+$/u.test(text) && !/[\\p{L}\\u4e00-\\u9fa5]/.test(text)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  // 获取元素文本内容\n  _getElementText(element) {\n    // 额外的安全检查，确保script内容不会被处理\n    if (element.tagName === 'SCRIPT' || element.closest('script')) {\n      return null;\n    }\n\n    // 使用TreeWalker遍历元素的所有文本节点\n    let textContent = '';\n    const treeWalker = document.createTreeWalker(\n      element,\n      NodeFilter.SHOW_TEXT,\n      {\n        acceptNode: function (node) {\n          // 跳过script标签内的文本节点\n          if (node.parentNode.tagName === 'SCRIPT' || node.parentNode.closest('script')) {\n            return NodeFilter.FILTER_REJECT;\n          }\n\n          // 只获取直接的文本节点，跳过深层元素内的文本\n          if (node.parentNode !== element) {\n            return NodeFilter.FILTER_SKIP;\n          }\n          return NodeFilter.FILTER_ACCEPT;\n        }\n      }\n    );\n\n    let node;\n    while (node = treeWalker.nextNode()) {\n      const text = node.textContent.trim();\n      if (text) {\n        textContent += text + ' ';\n      }\n    }\n\n    return textContent.trim();\n  }\n\n  // 应用翻译\n  _applyTranslation(element, originalText, translatedText) {\n    if (!translatedText || originalText === translatedText) {\n      return;\n    }\n    \n    // 标记已翻译\n    element.classList.add(this.config.doneClass);\n    \n    // 如果元素有子元素，只替换直接的文本节点\n    if (element.childElementCount > 0) {\n      const treeWalker = document.createTreeWalker(\n        element,\n        NodeFilter.SHOW_TEXT,\n        {\n          acceptNode: function(node) {\n            if (node.parentNode !== element) {\n              return NodeFilter.FILTER_SKIP;\n            }\n            return NodeFilter.FILTER_ACCEPT;\n          }\n        }\n      );\n      \n      // 记录原始文本中的所有文本节点\n      const textNodes = [];\n      \n      let node;\n      while (node = treeWalker.nextNode()) {\n        if (node.textContent.trim()) {\n          textNodes.push(node);\n        }\n      }\n      \n      // 如果只有一个文本节点，直接替换\n      if (textNodes.length === 1) {\n        const leadingSpaces = textNodes[0].textContent.match(/^\\s*/)[0];\n        const trailingSpaces = textNodes[0].textContent.match(/\\s*$/)[0];\n        textNodes[0].textContent = leadingSpaces + translatedText + trailingSpaces;\n      }\n      // 如果有多个文本节点，我们需要更复杂的处理，这里简单处理为清空所有并在第一个放置原文\n      else if (textNodes.length > 1) {\n        // 清空所有文本节点\n        for (let i = 1; i < textNodes.length; i++) {\n          textNodes[i].textContent = '';\n        }\n        \n        // 在第一个节点放置所有原始文本\n        if (textNodes[0]) {\n          const leadingSpaces = textNodes[0].textContent.match(/^\\s*/)[0];\n          const trailingSpaces = textNodes[0].textContent.match(/\\s*$/)[0];\n          textNodes[0].textContent = leadingSpaces + translatedText + trailingSpaces;\n        }\n      }\n    } else {\n      // 如果没有子元素，保留原始文本中的空格\n      const leadingSpaces = element.textContent.match(/^\\s*/)[0];\n      const trailingSpaces = element.textContent.match(/\\s*$/)[0];\n      element.textContent = leadingSpaces + translatedText + trailingSpaces;\n    }\n  }\n}\n\nexport default Tranzy; "],"names":["DEFAULT_IGNORE_SELECTORS","DEFAULT_CONFIG","toLang","navigator","language","fromLang","root","ignore","force","doneClass","pendingClass","auto","batch","translator","manualDict","hooks","before","after","beforeElement","afterElement","mergeDeep","objects","reduce","prev","obj","Object","keys","forEach","key","pVal","oVal","Array","isArray","from","Set","isObject","item","TranslationCache","constructor","this","dbName","storeName","db","initPromise","_initDatabase","_generateHash","str","hash","i","length","charCodeAt","toString","Promise","resolve","reject","request","indexedDB","open","onupgradeneeded","event","target","result","objectStoreNames","contains","createObjectStore","keyPath","onsuccess","onerror","error","get","text","id","transaction","objectStore","value","set","translation","put","getBatch","texts","results","fill","remainingIndices","all","map","async","index","cachedTranslation","push","setBatch","translations","MicrosoftTranslator","tokenExpireMinutes","_loadTokenFromSession","tokenData","sessionStorage","getItem","token","timestamp","JSON","parse","now","Date","authToken","tokenTimestamp","_clearTokenFromSession","_saveTokenToSession","setItem","stringify","removeItem","getAuthToken","response","fetch","method","headers","ok","Error","status","statusText","translate","filteredTexts","filter","trim","url","data","Text","Authorization","body","json","config","lang","langDict","term","to","standalone","case","cache","isTranslating","pendingElements","observer","observerConfig","childList","subtree","init","translatePage","startObserver","disconnect","MutationObserver","mutations","shouldTranslate","mutation","type","addedNodes","node","nodeType","Node","ELEMENT_NODE","treeWalker","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","some","selector","matches","FILTER_ACCEPT","FILTER_REJECT","bind","currentNode","add","nextNode","parentNode","shouldSkip","parent","_translatePending","observe","stopObserver","size","elements","clear","_translateElements","wasObserving","rootElement","querySelector","classList","FILTER_SKIP","validElements","el","_getElementText","batchSize","slice","_translateElementBatch","_splitByTerms","toLangDict","terms","sort","a","b","toLowerCase","includes","parts","currentText","foundTerm","flags","match","RegExp","exec","substring","elementsWithText","textsToTranslate","element","_shouldTranslateText","translationMap","termPartsMap","textsToCheckCache","finalTextsToFetch","part","cacheResults","cacheIndex","apiResults","apiIndex","originalText","entries","translatedParts","join","translatedText","remove","_applyTranslation","test","tagName","closest","textContent","SHOW_TEXT","childElementCount","textNodes","leadingSpaces","trailingSpaces"],"mappings":"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"}