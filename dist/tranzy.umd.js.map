{"version":3,"file":"tranzy.umd.js","sources":["../src/tranzy.js"],"sourcesContent":["/**\n * Tranzy - 网页自动翻译插件\n *\n * 主要功能：\n * 1. 自动检测DOM变化并翻译新增内容\n * 2. 支持批量翻译和缓存机制\n * 3. 提供灵活的配置选项和钩子函数\n * 4. 支持手动翻译词典和术语处理\n * 5. 内置微软翻译API实现\n *\n * 使用方式：\n * 1. 直接使用翻译功能：\n *    import { translateText } from 'tranzy';\n *    const result = await translateText(['Hello'], 'zh', 'en');\n *\n * 2. 使用页面翻译功能：\n *    import Tranzy from 'tranzy';\n *    const tranzy = new Tranzy({\n *      toLang: 'zh',\n *      fromLang: 'en'\n *    });\n *    await tranzy.translatePage();\n *\n * @author Fts Cloud <ftsuperb@vip.qq.com>\n * @license MIT\n * @repository https://github.com/FtsCloud/Tranzy\n * @copyright Copyright (c) 2023-present Fts Cloud\n */\n\n// 默认忽略的选择器列表，这些元素及其内容不会被翻译\nconst DEFAULT_IGNORE_SELECTORS = [\n  'style',            // 样式标签\n  'script',           // 脚本标签\n  'noscript',         // 无脚本标签\n  'kbd',              // 键盘输入标签\n  'code',             // 代码标签\n  'pre',              // 预格式化文本标签\n  'input',            // 输入框\n  'textarea',         // 文本域\n  '[contenteditable=\"true\"]', // 可编辑元素\n  '.tranzy-ignore'    // 自定义忽略类\n];\n\n// 默认配置选项\nconst DEFAULT_CONFIG = {\n  toLang: navigator.language || '',    // 目标语言，默认从浏览器语言设置获取\n  fromLang: '',                        // 源语言，如：'en'\n  ignore: [],                          // 自定义忽略选择器列表\n  force: [],                           // 强制翻译选择器列表\n  doneClass: 'tranzy-done',            // 已翻译元素的标记类\n  pendingClass: 'tranzy-pending',      // 正在翻译中的元素标记类\n  batch: 100,                          // 批量翻译时的批次大小\n  translatorFn: translateText,          // 默认使用translateText函数\n  manualDict: {},                      // 手动翻译词典\n  beforeTranslate: null,               // 翻译开始前的钩子\n  afterTranslate: null,                // 翻译结束后的钩子\n};\n\n/**\n * 翻译缓存管理器\n * 使用IndexedDB存储翻译结果，提高性能并减少API调用\n */\nclass TranslationCache {\n  constructor() {\n    this.dbName = 'tranzy-cache';      // 数据库名称\n    this.storeName = 'translations';    // 存储对象名称\n    this.db = null;                     // 数据库实例\n    this.initPromise = this._initDatabase(); // 初始化Promise\n  }\n\n  /**\n   * 生成字符串哈希值\n   * 使用FNV-1a哈希算法，生成base36编码的短哈希值\n   * @param {string} str - 需要哈希的字符串\n   * @returns {string} - base36编码的哈希值\n   */\n  _generateHash(str) {\n    let hash = 2166136261;\n    for (let i = 0; i < str.length; i++) {\n      hash ^= str.charCodeAt(i);\n      hash *= 16777619;\n    }\n    return hash.toString(36);\n  }\n\n  /**\n   * 初始化IndexedDB数据库\n   * 创建数据库和存储对象，处理版本升级\n   * @returns {Promise} - 初始化完成的Promise\n   */\n  async _initDatabase() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, 1);\n\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          db.createObjectStore(this.storeName, {keyPath: 'id'});\n        }\n      };\n\n      request.onsuccess = (event) => {\n        this.db = event.target.result;\n        resolve();\n      };\n\n      request.onerror = (event) => {\n        console.error('Tranzy: Failed to initialize cache database / 初始化缓存数据库失败', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  }\n\n  /**\n   * 获取缓存的翻译结果\n   * @param {string} text - 原文\n   * @param {string} toLang - 目标语言\n   * @param {string} [fromLang=''] - 源语言\n   * @returns {Promise<string|null>} - 缓存的翻译结果或null\n   */\n  async get(text, toLang, fromLang = '') {\n    await this.initPromise;\n    const id = this._generateHash(`${text}|${toLang}|${fromLang}`);\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve(null);\n        return;\n      }\n\n      const transaction = this.db.transaction(this.storeName, 'readonly');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.get(id);\n\n      request.onsuccess = (event) => {\n        resolve(event.target.result?.value || null);\n      };\n\n      request.onerror = () => {\n        resolve(null);\n      };\n    });\n  }\n\n  /**\n   * 设置翻译结果到缓存\n   * @param {string} text - 原文\n   * @param {string} translation - 翻译结果\n   * @param {string} toLang - 目标语言\n   * @param {string} [fromLang=''] - 源语言\n   * @returns {Promise<void>}\n   */\n  async set(text, translation, toLang, fromLang = '') {\n    await this.initPromise;\n    const id = this._generateHash(`${text}|${toLang}|${fromLang}`);\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve();\n        return;\n      }\n\n      const transaction = this.db.transaction(this.storeName, 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.put({\n        id,\n        value: translation\n      });\n\n      request.onsuccess = () => {\n        resolve();\n      };\n\n      request.onerror = () => {\n        resolve();\n      };\n    });\n  }\n\n  /**\n   * 批量设置翻译结果到缓存\n   * @param {string[]} texts - 原文数组\n   * @param {string[]} translations - 翻译结果数组\n   * @param {string} toLang - 目标语言\n   * @param {string} [fromLang=''] - 源语言\n   * @returns {Promise<void>}\n   */\n  async setBatch(texts, translations, toLang, fromLang = '') {\n    await this.initPromise;\n    await Promise.all(texts.map((text, index) => {\n      return this.set(text, translations[index], toLang, fromLang);\n    }));\n  }\n}\n\n/**\n * 从sessionStorage加载认证token\n * @returns {{token: string|null, timestamp: number}} - token和获取时间戳\n */\nfunction loadTokenFromSession() {\n  try {\n    const tokenData = sessionStorage.getItem('tranzy_auth_token');\n    if (tokenData) {\n      const {\n        token,\n        timestamp\n      } = JSON.parse(tokenData);\n      const now = Date.now();\n      // 如果token未过期，则使用缓存的token\n      if (token && (now - timestamp) < 10 * 60 * 1000) {\n        return {\n          token,\n          timestamp\n        };\n      }\n      // token已过期，清除缓存\n      clearTokenFromSession();\n    }\n  } catch (error) {\n    console.error('Tranzy: Failed to load token from session / 从session加载token失败', error);\n    clearTokenFromSession();\n  }\n  return {\n    token: null,\n    timestamp: 0\n  };\n}\n\n/**\n * 保存认证token到sessionStorage\n * @param {string} token - 认证token\n * @param {number} timestamp - 获取时间戳\n */\nfunction saveTokenToSession(token, timestamp) {\n  try {\n    sessionStorage.setItem('tranzy_auth_token', JSON.stringify({\n      token,\n      timestamp\n    }));\n  } catch (error) {\n    console.error('Tranzy: Failed to save token to session / 保存token到session失败', error);\n  }\n}\n\n/**\n * 清除sessionStorage中的认证token\n */\nfunction clearTokenFromSession() {\n  try {\n    sessionStorage.removeItem('tranzy_auth_token');\n  } catch (error) {\n    console.error('Tranzy: Failed to clear token from session / 清除session中的token失败', error);\n  }\n}\n\n/**\n * 获取微软翻译API的认证token\n * 优先使用缓存的token，如果过期则重新获取\n * @returns {Promise<string>} - 认证token\n */\nasync function getAuthToken() {\n  const now = Date.now();\n  const {\n    token,\n    timestamp\n  } = loadTokenFromSession();\n\n  // 如果token获取时间小于10分钟，则直接返回\n  if (token && (now - timestamp) < 10 * 60 * 1000) {\n    return token;\n  }\n\n  try {\n    const response = await fetch('https://edge.microsoft.com/translate/auth', {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      }\n    });\n\n    if (!response.ok) {\n      console.error(`Tranzy: Failed to get Microsoft Translator authorization / 获取微软翻译授权失败: ${response.status} ${response.statusText}`);\n      return null;\n    }\n\n    const newToken = await response.text();\n    saveTokenToSession(newToken, now);\n\n    return newToken;\n  } catch (error) {\n    console.error('Tranzy: Failed to get Microsoft Translator authorization / 获取微软翻译授权失败', error);\n    clearTokenFromSession();\n    throw error;\n  }\n}\n\n/**\n * 调用微软翻译API进行翻译\n * @param {string[]} texts - 需要翻译的文本数组\n * @param {string} toLang - 目标语言代码\n * @param {string} [fromLang=''] - 源语言代码\n * @returns {Promise<string[]>} - 翻译结果数组\n */\nexport async function translateText(texts, toLang = navigator.language, fromLang = '') {\n  try {\n    // 过滤掉空文本和null值\n    const filteredTexts = texts.filter(text => text?.trim());\n\n    // 如果没有有效文本需要翻译，直接返回空数组\n    if (filteredTexts.length === 0) {\n      return [];\n    }\n\n    // 获取认证令牌\n    const token = await getAuthToken();\n\n    // 构建URL，只在设置了fromLang时添加from参数\n    const url = `https://api.cognitive.microsofttranslator.com/translate?${fromLang ? `from=${fromLang}&` : ''}to=${toLang}&api-version=3.0`\n\n    // 构建请求数据\n    const data = filteredTexts.map(text => ({Text: text}));\n\n    // 发送请求\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`\n      },\n      body: JSON.stringify(data)\n    });\n\n    if (!response.ok) {\n      console.error(`Tranzy: Translation request failed / 翻译请求失败: ${response.status} ${response.statusText}`);\n      return texts; // 返回原文\n    }\n\n    // 处理响应\n    const result = await response.json();\n    return result.map(item => item.translations[0].text);\n  } catch (error) {\n    console.error('Tranzy: Translation request failed / 翻译请求失败', error);\n    throw error;\n  }\n}\n\n/**\n * 检测文本的语言\n * @param {string|string[]} texts - 需要检测语言的文本或文本数组\n * @returns {Promise<Array<{language: string, score: number, isTranslationSupported: boolean, isTransliterationSupported: boolean}>>} - 语言检测结果数组\n */\nexport async function detectLang(texts) {\n  try {\n    // 确保texts是数组\n    const textArray = Array.isArray(texts) ? texts : [texts];\n\n    // 过滤掉空文本和null值\n    const filteredTexts = textArray.filter(text => text?.trim());\n\n    // 如果没有有效文本需要检测，直接返回空数组\n    if (filteredTexts.length === 0) {\n      return [];\n    }\n\n    // 获取认证令牌\n    const token = await getAuthToken();\n\n    // 构建请求数据\n    const data = filteredTexts.map(text => ({Text: text}));\n\n    // 发送请求\n    const response = await fetch('https://api.cognitive.microsofttranslator.com/detect?api-version=3.0', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`\n      },\n      body: JSON.stringify(data)\n    });\n\n    if (!response.ok) {\n      console.error(`Tranzy: Language detection request failed / 语言检测请求失败: ${response.status} ${response.statusText}`);\n      return []; // 返回空数组\n    }\n\n    // 处理响应\n    return await response.json();\n  } catch (error) {\n    console.error('Tranzy: Language detection failed / 语言检测失败', error);\n    throw error;\n  }\n}\n\n/**\n * 获取支持的语种列表\n * @param {string} [displayLang=''] - 用于显示语言名称的BCP 47语言代码，例如：'zh-CN'表示用简体中文显示语言名称\n * @returns {Promise<Object>} - 支持的语种列表，格式为 { languageCode: { name: string, nativeName: string, dir: string } }\n * 注意：所有语言代码均遵循BCP 47规范，例如：'zh-CN'、'en'、'ja'等\n */\nexport async function getSupportedLangs(displayLang = '') {\n  try {\n    // 构建请求头\n    const headers = {\n      'Content-Type': 'application/json'\n    };\n\n    // 如果指定了显示语言，添加到请求头\n    if (displayLang) {\n      headers['Accept-Language'] = displayLang;\n    }\n\n    // 发送请求\n    const response = await fetch('https://api.cognitive.microsofttranslator.com/languages?api-version=3.0', {\n      method: 'GET',\n      headers\n    });\n\n    if (!response.ok) {\n      console.error(`Tranzy: Failed to get supported languages / 获取支持语种列表失败: ${response.status} ${response.statusText}`);\n      return {}; // 返回空对象\n    }\n\n    // 处理响应，只返回translation部分\n    const result = await response.json();\n    return result.translation;\n  } catch (error) {\n    console.error('Tranzy: Failed to get supported languages / 获取支持语种列表失败', error);\n    throw error;\n  }\n}\n\n/**\n * 获取浏览器语言对应的支持语言代码\n * @returns {Promise<string>} - 支持的语言代码，例如：'zh-Hans'、'en'等\n * 注意：返回的语言代码遵循BCP 47规范\n */\nexport async function getBrowserLang() {\n  try {\n    // 获取浏览器语言\n    const browserLang = navigator.language;\n\n    // 获取认证令牌\n    const token = await getAuthToken();\n\n    // 发送请求，翻译空字符串\n    const response = await fetch(`https://api.cognitive.microsofttranslator.com/translate?to=${browserLang}&api-version=3.0`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`\n      },\n      body: JSON.stringify([{Text: ''}])\n    });\n\n    if (!response.ok) {\n      console.error(`Tranzy: Failed to get browser language / 获取浏览器语言失败: ${response.status} ${response.statusText}`);\n      return navigator.language || 'en'; // 返回浏览器语言或默认英语\n    }\n\n    // 处理响应，获取支持的语言代码\n    const result = await response.json();\n    return result[0].translations[0].to;\n  } catch (error) {\n    console.error('Tranzy: Failed to get browser language / 获取浏览器语言失败', error);\n    throw error;\n  }\n}\n\n/**\n * Tranzy核心类\n * 提供页面翻译和DOM变化监听功能\n */\nclass Tranzy {\n  /**\n   * 创建Tranzy实例\n   * @param {Object} config - 配置选项\n   * @param {string} config.toLang - 目标语言代码\n   * @param {string} [config.fromLang=''] - 源语言代码\n   * @param {string[]} [config.ignore=[]] - 忽略的选择器列表\n   * @param {string[]} [config.force=[]] - 强制翻译的选择器列表\n   * @param {string} [config.doneClass='tranzy-done'] - 已翻译元素的标记类\n   * @param {string} [config.pendingClass='tranzy-pending'] - 正在翻译中的元素标记类\n   * @param {number} [config.batch=100] - 批量翻译的批次大小\n   * @param {Function} [config.translatorFn=null] - 自定义翻译函数\n   * @param {Object} [config.manualDict={}] - 手动翻译词典\n   * @param {Function} [config.beforeTranslate=null] - 翻译开始前的钩子\n   * @param {Function} [config.afterTranslate=null] - 翻译结束后的钩子\n   */\n  constructor(config = {}) {\n    this.config = {...DEFAULT_CONFIG, ...config};\n\n    // 合并 all 配置到当前语言的配置中，all 的优先级更高\n    this.config.manualDict[this.config.toLang] = {\n      ...this.config.manualDict[this.config.toLang] || {}, ...this.config.manualDict.all || {}\n    };\n\n    // 标准化manualDict配置\n    const langDict = this.config.manualDict[this.config.toLang];\n    for (const term of Object.keys(langDict)) {\n      // 如果翻译值是字符串，转换为标准格式\n      if (typeof langDict[term] === 'string') {\n        langDict[term] = {\n          to: langDict[term],\n          standalone: true,\n          case: true\n        };\n      }\n    }\n\n    this.observer = null;\n    this.translationCache = new TranslationCache();\n\n    // 合并并去重忽略选择器\n    this.config.ignore = [\n      ...new Set([\n        ...DEFAULT_IGNORE_SELECTORS,\n        ...(this.config.ignore || [])\n      ])\n    ];\n\n    // 确保强制翻译选择器是数组\n    this.config.force = this.config.force || [];\n\n    // 将数组选择器合并为字符串选择器，提高性能\n    this.forceSelectorString = this.config.force.length ? this.config.force.join(',') : '';\n    this.ignoreSelectorString = this.config.ignore.length ? this.config.ignore.join(',') : '';\n\n    // 初始化状态\n    this.isTranslating = false;         // 是否正在翻译\n    this.pendingElements = new Set();   // 待翻译元素集合\n    this.observerConfig = {             // 观察器配置\n      childList: true,                  // 观察子节点变化\n      subtree: true,                    // 观察后代节点变化\n      characterData: true               // 观察文本内容变化\n    };\n  }\n\n  /**\n   * 创建节点过滤器\n   * 用于TreeWalker，决定哪些节点需要被翻译\n   * @returns {Object} - 节点过滤器对象\n   */\n  _createNodeFilter() {\n    return {\n      acceptNode: function (node) {\n        // 跳过已翻译的元素，但允许检查其子元素\n        if (node.classList.contains(this.config.doneClass)) {\n          return NodeFilter.FILTER_SKIP;\n        }\n\n        // 优先级1：检查当前节点是否匹配force选择器\n        if (this.forceSelectorString && node.matches(this.forceSelectorString)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        // 优先级2：检查父节点是否匹配force选择器\n        if (this.forceSelectorString) {\n          let parent = node.parentNode;\n          while (parent && parent !== document) {\n            if (parent.matches(this.forceSelectorString)) {\n              return NodeFilter.FILTER_ACCEPT;\n            }\n            parent = parent.parentNode;\n          }\n        }\n\n        // 优先级3：检查子节点是否匹配force选择器\n        let hasForceChild = false;\n        if (this.forceSelectorString && node.children.length > 0) {\n          hasForceChild = node.querySelector(this.forceSelectorString);\n        }\n\n        // 优先级4：检查当前节点是否匹配ignore选择器\n        if (this.ignoreSelectorString && node.matches(this.ignoreSelectorString)) {\n          return hasForceChild ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;\n        }\n\n        // 优先级5：检查父节点是否匹配ignore选择器\n        if (this.ignoreSelectorString) {\n          let parent = node.parentNode;\n          while (parent && parent !== document) {\n            if (parent.matches(this.ignoreSelectorString)) {\n              return hasForceChild ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;\n            }\n            parent = parent.parentNode;\n          }\n        }\n\n        // 默认接受：如果以上所有条件都不满足，接受节点进行翻译\n        return NodeFilter.FILTER_ACCEPT;\n      }.bind(this)\n    };\n  }\n\n  /**\n   * 开始观察DOM变化\n   * @param {string} [root='body'] - 观察的根元素选择器\n   * @returns {Tranzy} - 当前实例，支持链式调用\n   */\n  startObserver(root = 'body') {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n\n    this.observer = new MutationObserver((mutations) => {\n      let shouldTranslate = false;\n      for (const mutation of mutations) {\n        // 处理新增节点\n        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n          for (const node of mutation.addedNodes) {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n              // 使用TreeWalker遍历所有元素节点\n              const treeWalker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, this._createNodeFilter());\n\n              // 收集所有符合条件的元素\n              let currentNode = treeWalker.nextNode();\n              while (currentNode) {\n                this.pendingElements.add(currentNode);\n                shouldTranslate = true;\n                currentNode = treeWalker.nextNode();\n              }\n            }\n          }\n        }\n\n        // 处理文本变化\n        if (mutation.type === 'characterData') {\n          const node = mutation.target.parentNode;\n          if (node && node.nodeType === Node.ELEMENT_NODE) {\n            // 检查节点是否正在翻译中\n            if (node.classList.contains(this.config.pendingClass)) {\n              continue;\n            }\n\n            // 检查所有父元素，如果有任何父元素被忽略且不在强制翻译列表中，则跳过\n            let shouldSkip = false;\n            let parent = node;\n\n            while (parent) {\n              if (this.ignoreSelectorString && parent.matches(this.ignoreSelectorString) && !(this.forceSelectorString && parent.matches(this.forceSelectorString))) {\n                shouldSkip = true;\n                break;\n              }\n              parent = parent.parentNode;\n              if (!parent || parent === document) {\n                break;\n              }\n            }\n\n            if (!shouldSkip) {\n              this.pendingElements.add(node);\n              shouldTranslate = true;\n            }\n          }\n        }\n      }\n\n      if (shouldTranslate) {\n        // 直接翻译\n        this._translatePending();\n      }\n    });\n\n    this.observer.observe(document.querySelector(root), this.observerConfig);\n\n    return this;\n  }\n\n  /**\n   * 停止观察DOM变化\n   * @returns {Tranzy} - 当前实例，支持链式调用\n   */\n  stopObserver() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n\n    return this;\n  }\n\n  /**\n   * 翻译待处理元素\n   * @param {boolean} [again=false] - 是否是重复翻译\n   * @private\n   */\n  async _translatePending(again = false) {\n    if (this.pendingElements.size === 0 || this.isTranslating) {\n      return;\n    }\n\n    if (!again && typeof this.config.beforeTranslate === 'function') {\n      this.config.beforeTranslate();\n    }\n\n    this.isTranslating = true;\n\n    const elements = Array.from(this.pendingElements);\n    this.pendingElements.clear();\n\n    await this._translateElements(elements);\n\n    this.isTranslating = false;\n\n    // 检查是否有新的待处理元素\n    if (this.pendingElements.size > 0) {\n      this._translatePending(true);\n    } else {\n      if (typeof this.config.afterTranslate === 'function') {\n        this.config.afterTranslate();\n      }\n    }\n  }\n\n  /**\n   * 翻译整个页面\n   * @param {string} [root='body'] - 翻译的根元素选择器\n   * @returns {Promise<Tranzy>} - 当前实例，支持链式调用\n   */\n  async translatePage(root = 'body') {\n    if (this.isTranslating) {\n      return this;\n    }\n\n    this.isTranslating = true;\n\n    // 临时停止观察器，避免翻译过程中触发更多的变化\n    const wasObserving = !!this.observer;\n    if (wasObserving) {\n      this.stopObserver();\n    }\n\n    // 执行beforeTranslate钩子\n    if (typeof this.config.beforeTranslate === 'function') {\n      this.config.beforeTranslate();\n    }\n\n    try {\n      // 使用TreeWalker获取所有需要翻译的元素\n      const elements = [];\n      const rootElement = document.querySelector(root);\n\n      // 创建TreeWalker，只显示元素节点\n      const treeWalker = document.createTreeWalker(rootElement, NodeFilter.SHOW_ELEMENT, this._createNodeFilter());\n\n      // 收集所有符合条件的元素\n      let node = treeWalker.nextNode();\n      while (node) {\n        elements.push(node);\n        node = treeWalker.nextNode();\n      }\n\n      await this._translateElements(elements);\n    } catch (error) {\n      console.error('Tranzy: Page translation failed / 页面翻译失败', error);\n    } finally {\n      // 执行afterTranslate钩子\n      if (typeof this.config.afterTranslate === 'function') {\n        this.config.afterTranslate();\n      }\n\n      this.isTranslating = false;\n\n      // 如果之前在观察，重新启动观察器\n      if (wasObserving) {\n        this.startObserver(root);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * 翻译元素数组\n   * @param {Element[]} elements - 需要翻译的元素数组\n   * @private\n   */\n  async _translateElements(elements) {\n    // 过滤出需要翻译的元素并保存文本\n    const validElements = [];\n    const elementsText = [];\n\n    for (const el of elements) {\n      const text = this._getElementText(el);\n      if (text) {\n        validElements.push(el);\n        elementsText.push(text);\n      }\n    }\n\n    if (validElements.length === 0) {\n      return;\n    }\n\n    // 批量处理元素\n    const batchSize = this.config.batch;\n    for (let i = 0; i < validElements.length; i += batchSize) {\n      const batchElements = validElements.slice(i, i + batchSize);\n      const batchTexts = elementsText.slice(i, i + batchSize);\n      await this._translateElementBatch(batchElements, batchTexts);\n    }\n  }\n\n  /**\n   * 检查文本中是否包含术语并拆分\n   * @param {string} text - 需要检查的文本\n   * @returns {string[]} - 拆分后的文本数组\n   * @private\n   */\n  _splitByTerms(text) {\n    const toLangDict = this.config.manualDict[this.config.toLang];\n    if (!toLangDict) {\n      return [text];\n    }\n\n    // 按长度降序排序术语，优先匹配最长的术语\n    const terms = Object.keys(toLangDict).sort((a, b) => b.length - a.length);\n\n    // 先检查是否有完全匹配的术语\n    for (const term of terms) {\n      const translation = toLangDict[term];\n      // 如果是独立匹配模式（默认为true）且文本完全等于术语\n      if ((translation.standalone !== false) && (translation.case === false ? text.toLowerCase() === term.toLowerCase() : text === term)) {\n        return [text];\n      }\n    }\n\n    // 如果没有完全匹配，且文本中没有包含任何术语，直接返回原文本\n    let containsAnyTerm = false;\n    for (const term of terms) {\n      const translation = toLangDict[term];\n      if (translation.case === false ? text.toLowerCase().includes(term.toLowerCase()) : text.includes(term)) {\n        containsAnyTerm = true;\n        break;\n      }\n    }\n\n    if (!containsAnyTerm) {\n      return [text];\n    }\n\n    // 拆分文本\n    const parts = [];\n    let currentText = text;\n\n    while (currentText.length > 0) {\n      let foundTerm = false;\n      for (const term of terms) {\n        const translation = toLangDict[term];\n        // 跳过需要独立匹配的术语\n        if (translation.standalone !== false) {\n          continue;\n        }\n\n        // 使用正则表达式匹配术语，根据case配置决定是否忽略大小写\n        const flags = translation.case === false ? 'gi' : 'g';\n        const termRegex = new RegExp(`\\\\b${term}\\\\b`, flags);\n        const match = termRegex.exec(currentText);\n\n        if (match) {\n          const index = match.index;\n          // 如果术语前面有文本，添加为一部分\n          if (index > 0) {\n            parts.push(currentText.substring(0, index));\n          }\n          // 添加术语\n          parts.push(term);\n          // 更新剩余文本\n          currentText = currentText.substring(index + term.length);\n          foundTerm = true;\n          break;\n        }\n      }\n      // 如果没有找到术语，将剩余文本作为一部分\n      if (!foundTerm) {\n        parts.push(currentText);\n        break;\n      }\n    }\n\n    return parts;\n  }\n\n  /**\n   * 获取元素的直接文本节点\n   * @param {Element} element - 需要获取文本节点的元素\n   * @returns {Array<{node: Text, text: string, leadingSpaces: string, trailingSpaces: string}>} - 文本节点信息数组\n   * @private\n   */\n  _getDirectTextNodes(element) {\n    const textNodes = [];\n    const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, {\n      acceptNode: (node) => {\n        if (node.parentNode !== element) {\n          return NodeFilter.FILTER_SKIP;\n        }\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    });\n\n    let node = treeWalker.nextNode();\n    while (node) {\n      const text = node.textContent;\n      const trimmed = text.trim();\n      if (trimmed) {\n        textNodes.push({\n          node,\n          text: trimmed,\n          leadingSpaces: text.match(/^\\s*/)[0],\n          trailingSpaces: text.match(/\\s*$/)[0]\n        });\n      }\n      node = treeWalker.nextNode();\n    }\n\n    return textNodes;\n  }\n\n  /**\n   * 批量翻译元素\n   * @param {Element[]} elements - 需要翻译的元素数组\n   * @param {string[]} textsArray - 对应的文本数组\n   * @private\n   */\n  async _translateElementBatch(elements, textsArray) {\n    // 收集需要翻译的文本和对应的元素\n    const elementsWithText = [];\n    const textsToTranslate = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      const text = textsArray[i];\n\n      // 将元素和文本添加到待处理列表\n      elementsWithText.push(element);\n      textsToTranslate.push(text);\n      // 标记元素为正在翻译状态，防止重复处理\n      element.classList.add(this.config.pendingClass);\n    }\n\n    if (textsToTranslate.length === 0) {\n      return;\n    }\n\n    // 创建元素到其直接文本节点的映射表\n    const nodeTextMap = new Map();\n\n    // 预处理每个元素，收集其直接文本节点\n    for (let i = 0; i < elementsWithText.length; i++) {\n      const element = elementsWithText[i];\n\n      // 如果元素包含子元素，需要单独处理每个文本节点\n      if (element.childElementCount > 0) {\n        // 收集元素的直接文本节点（不包含子元素的文本节点）\n        const textNodes = this._getDirectTextNodes(element);\n\n        // 如果元素包含多个文本节点，需要特殊处理\n        if (textNodes.length > 1) {\n          // 存储元素到其文本节点的映射关系，用于后续处理\n          nodeTextMap.set(element, textNodes);\n\n          // 为每个文本节点创建独立的翻译任务\n          for (const nodeInfo of textNodes) {\n            textsToTranslate.push(nodeInfo.text);\n            elementsWithText.push({\n              isTextNode: true,\n              nodeInfo\n            });\n          }\n\n          // 标记原始元素的翻译任务为跳过，因为已经为每个文本节点创建了独立任务\n          textsToTranslate[i] = null;\n        }\n      }\n    }\n\n    // 过滤掉被标记为跳过的元素和文本\n    const validElementTexts = elementsWithText.filter((_, i) => textsToTranslate[i] !== null);\n    const validTexts = textsToTranslate.filter(text => text !== null);\n\n    // 用术语替换处理每个文本\n    const termProcessedTexts = [];\n    const termMappings = new Map();\n\n    for (const text of validTexts) {\n      if (!text) {\n        continue;\n      }\n\n      // 检查文本中是否包含术语\n      const parts = this._splitByTerms(text);\n\n      // 如果被拆分，需要单独处理每个部分\n      if (parts.length > 1) {\n        termMappings.set(text, parts);\n        for (const part of parts) {\n          termProcessedTexts.push(part)\n        }\n      } else {\n        termProcessedTexts.push(text);\n      }\n    }\n\n    // 去重以减少翻译请求\n    const uniqueTextsToTranslate = [...new Set(termProcessedTexts)];\n\n    // 检查手动词典和缓存\n    const manualTranslations = {};\n    const textsToFetch = [];\n\n    for (const text of uniqueTextsToTranslate) {\n      // 检查手动词典\n      const toLangDict = this.config.manualDict[this.config.toLang];\n      const translation = toLangDict && (toLangDict[text] || (toLangDict[text.toLowerCase()]?.case === false ? toLangDict[text.toLowerCase()] : null));\n\n      if (translation) {\n        manualTranslations[text] = translation.to;\n      } else {\n        // 检查缓存\n        const cachedTranslation = await this.translationCache.get(text, this.config.toLang, this.config.fromLang);\n        if (cachedTranslation) {\n          manualTranslations[text] = cachedTranslation;\n        } else {\n          textsToFetch.push(text);\n        }\n      }\n    }\n\n    // 翻译未缓存的文本\n    if (textsToFetch.length > 0) {\n      try {\n        const apiResults = await this.config.translatorFn(textsToFetch, this.config.toLang, this.config.fromLang);\n\n        // 更新缓存\n        await this.translationCache.setBatch(textsToFetch, apiResults, this.config.toLang, this.config.fromLang);\n\n        // 合并翻译结果\n        textsToFetch.forEach((text, index) => {\n          manualTranslations[text] = apiResults[index];\n        });\n      } catch (error) {\n        console.error('Tranzy: Batch translation failed / 批量翻译失败', error);\n        for (const text of textsToFetch) {\n          manualTranslations[text] = text; // 错误时保持原文\n        }\n      }\n    }\n\n    // 构建最终翻译映射\n    const finalTranslations = new Map();\n\n    // 首先处理被术语拆分的文本\n    for (const [originalText, parts] of termMappings.entries()) {\n      const translatedParts = parts.map(part => manualTranslations[part] || part);\n      finalTranslations.set(originalText, translatedParts.join(''));\n    }\n\n    // 然后处理未被拆分的文本\n    for (const text of validTexts) {\n      if (!text || termMappings.has(text)) {\n        continue;\n      }\n      finalTranslations.set(text, manualTranslations[text] || text);\n    }\n\n    // 应用翻译结果\n    validElementTexts.forEach((element, index) => {\n      const originalText = validTexts[index];\n      if (!originalText) {\n        return;\n      }\n\n      const translatedText = finalTranslations.get(originalText);\n      if (!translatedText) {\n        return;\n      }\n\n      // 处理文本节点\n      if (element.isTextNode) {\n        const {\n          node,\n          leadingSpaces,\n          trailingSpaces\n        } = element.nodeInfo;\n        node.textContent = leadingSpaces + translatedText + trailingSpaces;\n\n        // 检查父元素是否已经处理完所有子节点\n        const parentElement = node.parentNode;\n        if (parentElement) {\n          // 等待下一个微任务，确保DOM更新完成\n          queueMicrotask(() => {\n            parentElement.classList.remove(this.config.pendingClass);\n            parentElement.classList.add(this.config.doneClass);\n          });\n        }\n      } else {\n        // 如果是简单元素(没有被分解为单独节点)，直接应用翻译\n        if (!nodeTextMap.has(element)) {\n          this._applyTranslation(element, originalText, translatedText);\n          // 等待下一个微任务，确保DOM更新完成\n          queueMicrotask(() => {\n            element.classList.remove(this.config.pendingClass);\n            element.classList.add(this.config.doneClass);\n          });\n        } else {\n          // 已经单独处理了各个文本节点，只需标记为已翻译\n          // 等待下一个微任务，确保DOM更新完成\n          queueMicrotask(() => {\n            element.classList.remove(this.config.pendingClass);\n            element.classList.add(this.config.doneClass);\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * 获取元素文本内容\n   * @param {Element} element - 需要获取文本的元素\n   * @returns {string|null} - 元素的文本内容，如果没有有效文本则返回null\n   * @private\n   */\n  _getElementText(element) {\n    // 使用TreeWalker遍历元素的所有文本节点\n    let textContent = '';\n    const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, {\n      acceptNode: (node) => {\n        // 只获取直接的文本节点，跳过深层元素内的文本\n        if (node.parentNode !== element) {\n          return NodeFilter.FILTER_SKIP;\n        }\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    });\n\n    let node = treeWalker.nextNode();\n    while (node) {\n      const text = node.textContent.trim();\n      if (text) {\n        textContent += `${text} `;\n      }\n      node = treeWalker.nextNode();\n    }\n\n    textContent = textContent.trim();\n\n    // 如果是空文本，直接返回null\n    if (!textContent || /^\\s*$/.test(textContent)) {\n      return null;\n    }\n\n    // 过滤掉只包含数字、空格、回车、特殊字符的文本\n    // 但保留包含中文、英文、数字的文本\n    if (/^[\\s\\d!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~]+$/.test(textContent) && !/[a-zA-Z\\u4e00-\\u9fa5]/.test(textContent)) {\n      return null;\n    }\n\n    return textContent;\n  }\n\n  /**\n   * 应用翻译结果到元素\n   * @param {Element} element - 需要应用翻译的元素\n   * @param {string} originalText - 原始文本\n   * @param {string} translatedText - 翻译后的文本\n   * @private\n   */\n  _applyTranslation(element, originalText, translatedText) {\n    if (!translatedText || originalText === translatedText) {\n      return;\n    }\n\n    // 标记已翻译\n    element.classList.add(this.config.doneClass);\n\n    // 如果元素有子元素，只替换直接的文本节点\n    if (element.childElementCount > 0) {\n      // 1. 收集所有直接文本节点信息\n      const textNodes = this._getDirectTextNodes(element);\n\n      // 如果没有文本节点或只有一个文本节点，简单处理\n      if (textNodes.length === 0) {\n        return;\n      }\n      if (textNodes.length === 1) {\n        const { node, leadingSpaces, trailingSpaces } = textNodes[0];\n        node.textContent = leadingSpaces + translatedText + trailingSpaces;\n        return;\n      }\n\n      // 注意：多文本节点的情况已在_translateElementBatch中处理\n      // 这里作为备用方案，使用简单的按比例分配\n      const totalTextLength = textNodes.reduce((sum, item) => sum + item.text.length, 0);\n      let usedTranslationLength = 0;\n\n      textNodes.forEach((item, index) => {\n        const {\n          node,\n          text,\n          leadingSpaces,\n          trailingSpaces\n        } = item;\n        let nodeTranslation;\n\n        if (index === textNodes.length - 1) {\n          // 最后一个节点使用剩余的所有翻译文本\n          nodeTranslation = translatedText.substring(usedTranslationLength);\n        } else {\n          // 计算当前节点文本在原始完整文本中的占比\n          const ratio = text.length / totalTextLength;\n          // 根据比例计算应该分配的翻译文本长度\n          const translationLength = Math.round(translatedText.length * ratio);\n\n          // 从当前位置提取对应长度的翻译文本\n          nodeTranslation = translatedText.substring(usedTranslationLength, usedTranslationLength + translationLength);\n\n          // 更新已使用的翻译文本长度\n          usedTranslationLength += translationLength;\n        }\n\n        // 应用翻译结果到文本节点，保留原始空格\n        node.textContent = leadingSpaces + nodeTranslation + trailingSpaces;\n      });\n    } else {\n      // 如果没有子元素，保留原始文本中的空格\n      const leadingSpaces = element.textContent.match(/^\\s*/)[0];\n      const trailingSpaces = element.textContent.match(/\\s*$/)[0];\n      element.textContent = leadingSpaces + translatedText + trailingSpaces;\n    }\n  }\n\n  /**\n   * 销毁实例，释放资源\n   * @returns {Tranzy} - 当前实例，支持链式调用\n   */\n  destroy() {\n    // 停止DOM观察器\n    this.stopObserver();\n\n    // 清空待处理元素\n    this.pendingElements.clear();\n\n    // 关闭数据库连接\n    if (this.translationCache?.db) {\n      this.translationCache.db.close();\n      this.translationCache.db = null;\n    }\n\n    // 重置状态\n    this.isTranslating = false;\n\n    return this;\n  }\n}\n\nexport default Tranzy; "],"names":["DEFAULT_IGNORE_SELECTORS","DEFAULT_CONFIG","toLang","navigator","language","fromLang","ignore","force","doneClass","pendingClass","batch","translatorFn","translateText","manualDict","beforeTranslate","afterTranslate","TranslationCache","constructor","this","dbName","storeName","db","initPromise","_initDatabase","_generateHash","str","hash","i","length","charCodeAt","toString","Promise","resolve","reject","request","indexedDB","open","onupgradeneeded","event","target","result","objectStoreNames","contains","createObjectStore","keyPath","onsuccess","onerror","error","get","text","id","transaction","objectStore","value","set","translation","put","setBatch","texts","translations","all","map","index","clearTokenFromSession","sessionStorage","removeItem","async","getAuthToken","now","Date","token","timestamp","tokenData","getItem","JSON","parse","loadTokenFromSession","response","fetch","method","headers","ok","newToken","setItem","stringify","saveTokenToSession","filteredTexts","filter","trim","url","data","Text","Authorization","body","json","item","config","langDict","term","Object","keys","to","standalone","case","observer","translationCache","Set","forceSelectorString","join","ignoreSelectorString","isTranslating","pendingElements","observerConfig","childList","subtree","characterData","_createNodeFilter","acceptNode","node","classList","NodeFilter","FILTER_SKIP","matches","FILTER_ACCEPT","parent","parentNode","document","hasForceChild","children","querySelector","FILTER_REJECT","bind","startObserver","root","disconnect","MutationObserver","mutations","shouldTranslate","mutation","type","addedNodes","nodeType","Node","ELEMENT_NODE","treeWalker","createTreeWalker","SHOW_ELEMENT","currentNode","nextNode","add","shouldSkip","_translatePending","observe","stopObserver","again","size","elements","Array","from","clear","_translateElements","translatePage","wasObserving","rootElement","push","validElements","elementsText","el","_getElementText","batchSize","batchElements","slice","batchTexts","_translateElementBatch","_splitByTerms","toLangDict","terms","sort","a","b","toLowerCase","containsAnyTerm","includes","parts","currentText","foundTerm","flags","match","RegExp","exec","substring","_getDirectTextNodes","element","textNodes","SHOW_TEXT","textContent","trimmed","leadingSpaces","trailingSpaces","textsArray","elementsWithText","textsToTranslate","nodeTextMap","Map","childElementCount","nodeInfo","isTextNode","validElementTexts","_","validTexts","termProcessedTexts","termMappings","part","uniqueTextsToTranslate","manualTranslations","textsToFetch","cachedTranslation","apiResults","forEach","finalTranslations","originalText","entries","translatedParts","has","translatedText","parentElement","queueMicrotask","remove","_applyTranslation","test","totalTextLength","reduce","sum","usedTranslationLength","nodeTranslation","ratio","translationLength","Math","round","destroy","close","isArray","browserLang","displayLang"],"mappings":"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"}