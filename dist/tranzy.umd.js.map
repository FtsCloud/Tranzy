{"version":3,"file":"tranzy.umd.js","sources":["../src/tranzy.js"],"sourcesContent":["/**\n * Tranzy - 网页自动翻译插件\n * \n * 主要功能：\n * 1. 自动检测DOM变化并翻译新增内容\n * 2. 支持批量翻译和缓存机制\n * 3. 提供灵活的配置选项和钩子函数\n * 4. 支持手动翻译词典和术语处理\n * 5. 内置微软翻译API实现\n * \n * 使用方式：\n * 1. 直接使用翻译功能：\n *    import { translateText } from 'tranzy';\n *    const result = await translateText(['Hello'], 'zh', 'en');\n * \n * 2. 使用页面翻译功能：\n *    import Tranzy from 'tranzy';\n *    const tranzy = new Tranzy({\n *      toLang: 'zh',\n *      fromLang: 'en'\n *    });\n *    await tranzy.translatePage();\n * \n * @author Fts Cloud <ftsuperb@vip.qq.com>\n * @license MIT\n * @repository https://github.com/FtsCloud/Tranzy\n * @copyright Copyright (c) 2023-present Fts Cloud\n */\n\n// 默认忽略的选择器列表，这些元素及其内容不会被翻译\nconst DEFAULT_IGNORE_SELECTORS = [\n  'style',            // 样式标签\n  'script',           // 脚本标签\n  'noscript',         // 无脚本标签\n  'kbd',              // 键盘输入标签\n  'code',             // 代码标签\n  'pre',              // 预格式化文本标签\n  'input',            // 输入框\n  'textarea',         // 文本域\n  '[contenteditable=\"true\"]', // 可编辑元素\n  '.tranzy-ignore'    // 自定义忽略类\n];\n\n// 默认配置选项\nconst DEFAULT_CONFIG = {\n  toLang: navigator.language || '',    // 目标语言，默认从浏览器语言设置获取\n  fromLang: '',                        // 源语言，如：'en'\n  ignore: [],                          // 自定义忽略选择器列表\n  force: [],                           // 强制翻译选择器列表\n  doneClass: 'tranzy-done',            // 已翻译元素的标记类\n  pendingClass: 'tranzy-pending',      // 正在翻译中的元素标记类\n  batch: 100,                          // 批量翻译时的批次大小\n  translatorFn: translateText,          // 默认使用translateText函数\n  manualDict: {},                      // 手动翻译词典\n  beforeTranslate: null,               // 翻译开始前的钩子\n  afterTranslate: null,                // 翻译结束后的钩子\n};\n\n/**\n * 翻译缓存管理器\n * 使用IndexedDB存储翻译结果，提高性能并减少API调用\n */\nclass TranslationCache {\n  constructor() {\n    this.dbName = 'tranzy-cache';      // 数据库名称\n    this.storeName = 'translations';    // 存储对象名称\n    this.db = null;                     // 数据库实例\n    this.initPromise = this._initDatabase(); // 初始化Promise\n  }\n\n  /**\n   * 生成字符串哈希值\n   * 使用FNV-1a哈希算法，生成base36编码的短哈希值\n   * @param {string} str - 需要哈希的字符串\n   * @returns {string} - base36编码的哈希值\n   */\n  _generateHash(str) {\n    let hash = 2166136261;\n    for (let i = 0; i < str.length; i++) {\n      hash ^= str.charCodeAt(i);\n      hash *= 16777619;\n    }\n    return hash.toString(36);\n  }\n\n  /**\n   * 初始化IndexedDB数据库\n   * 创建数据库和存储对象，处理版本升级\n   * @returns {Promise} - 初始化完成的Promise\n   */\n  async _initDatabase() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, 1);\n\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          const store = db.createObjectStore(this.storeName, { keyPath: 'id' });\n        }\n      };\n\n      request.onsuccess = (event) => {\n        this.db = event.target.result;\n        resolve();\n      };\n\n      request.onerror = (event) => {\n        console.error('Tranzy: Failed to initialize cache database / 初始化缓存数据库失败', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  }\n\n  /**\n   * 获取缓存的翻译结果\n   * @param {string} text - 原文\n   * @param {string} toLang - 目标语言\n   * @param {string} [fromLang=''] - 源语言\n   * @returns {Promise<string|null>} - 缓存的翻译结果或null\n   */\n  async get(text, toLang, fromLang = '') {\n    await this.initPromise;\n    const id = this._generateHash(`${text}|${toLang}|${fromLang}`);\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve(null);\n        return;\n      }\n\n      const transaction = this.db.transaction(this.storeName, 'readonly');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.get(id);\n\n      request.onsuccess = (event) => {\n        resolve(event.target.result?.value || null);\n      };\n\n      request.onerror = () => {\n        resolve(null);\n      };\n    });\n  }\n\n  /**\n   * 设置翻译结果到缓存\n   * @param {string} text - 原文\n   * @param {string} translation - 翻译结果\n   * @param {string} toLang - 目标语言\n   * @param {string} [fromLang=''] - 源语言\n   * @returns {Promise<void>}\n   */\n  async set(text, translation, toLang, fromLang = '') {\n    await this.initPromise;\n    const id = this._generateHash(`${text}|${toLang}|${fromLang}`);\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve();\n        return;\n      }\n\n      const transaction = this.db.transaction(this.storeName, 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.put({\n        id,\n        value: translation\n      });\n\n      request.onsuccess = () => {\n        resolve();\n      };\n\n      request.onerror = () => {\n        resolve();\n      };\n    });\n  }\n\n  /**\n   * 批量获取缓存的翻译结果\n   * @param {string[]} texts - 原文数组\n   * @param {string} toLang - 目标语言\n   * @param {string} [fromLang=''] - 源语言\n   * @returns {Promise<{results: Array<string|null>, remainingIndices: number[]}>} - 缓存结果和未缓存的索引\n   */\n  async getBatch(texts, toLang, fromLang = '') {\n    await this.initPromise;\n    const results = Array(texts.length).fill(null);\n    const remainingIndices = [];\n\n    await Promise.all(texts.map(async (text, index) => {\n      const cachedTranslation = await this.get(text, toLang, fromLang);\n      if (cachedTranslation) {\n        results[index] = cachedTranslation;\n      } else {\n        remainingIndices.push(index);\n      }\n    }));\n\n    return {\n      results,\n      remainingIndices\n    };\n  }\n\n  /**\n   * 批量设置翻译结果到缓存\n   * @param {string[]} texts - 原文数组\n   * @param {string[]} translations - 翻译结果数组\n   * @param {string} toLang - 目标语言\n   * @param {string} [fromLang=''] - 源语言\n   * @returns {Promise<void>}\n   */\n  async setBatch(texts, translations, toLang, fromLang = '') {\n    await this.initPromise;\n    await Promise.all(texts.map((text, index) => {\n      return this.set(text, translations[index], toLang, fromLang);\n    }));\n  }\n}\n\n/**\n * 从sessionStorage加载认证token\n * @returns {{token: string|null, timestamp: number}} - token和获取时间戳\n */\nfunction loadTokenFromSession() {\n  try {\n    const tokenData = sessionStorage.getItem('tranzy_auth_token');\n    if (tokenData) {\n      const { token, timestamp } = JSON.parse(tokenData);\n      const now = Date.now();\n      // 如果token未过期，则使用缓存的token\n      if (token && (now - timestamp) < 10 * 60 * 1000) {\n        return { token, timestamp };\n      } else {\n        // token已过期，清除缓存\n        clearTokenFromSession();\n      }\n    }\n  } catch (error) {\n    console.error('Tranzy: Failed to load token from session / 从session加载token失败', error);\n    clearTokenFromSession();\n  }\n  return { token: null, timestamp: 0 };\n}\n\n/**\n * 保存认证token到sessionStorage\n * @param {string} token - 认证token\n * @param {number} timestamp - 获取时间戳\n */\nfunction saveTokenToSession(token, timestamp) {\n  try {\n    sessionStorage.setItem('tranzy_auth_token', JSON.stringify({ token, timestamp }));\n  } catch (error) {\n    console.error('Tranzy: Failed to save token to session / 保存token到session失败', error);\n  }\n}\n\n/**\n * 清除sessionStorage中的认证token\n */\nfunction clearTokenFromSession() {\n  try {\n    sessionStorage.removeItem('tranzy_auth_token');\n  } catch (error) {\n    console.error('Tranzy: Failed to clear token from session / 清除session中的token失败', error);\n  }\n}\n\n/**\n * 获取微软翻译API的认证token\n * 优先使用缓存的token，如果过期则重新获取\n * @returns {Promise<string>} - 认证token\n */\nasync function getAuthToken() {\n  const now = Date.now();\n  const { token, timestamp } = loadTokenFromSession();\n\n  // 如果token获取时间小于10分钟，则直接返回\n  if (token && (now - timestamp) < 10 * 60 * 1000) {\n    return token;\n  }\n\n  try {\n    const response = await fetch('https://edge.microsoft.com/translate/auth', {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      }\n    });\n\n    if (!response.ok) {\n      throw new Error(`Tranzy: Failed to get Microsoft Translator authorization / 获取微软翻译授权失败: ${response.status} ${response.statusText}`);\n    }\n\n    const newToken = await response.text();\n    saveTokenToSession(newToken, now);\n\n    return newToken;\n  } catch (error) {\n    console.error('Tranzy: Failed to get Microsoft Translator authorization / 获取微软翻译授权失败', error);\n    clearTokenFromSession();\n    throw error;\n  }\n}\n\n/**\n * 调用微软翻译API进行翻译\n * @param {string[]} texts - 需要翻译的文本数组\n * @param {string} toLang - 目标语言代码\n * @param {string} [fromLang=''] - 源语言代码\n * @returns {Promise<string[]>} - 翻译结果数组\n */\nexport async function translateText(texts, toLang = navigator.language, fromLang = '') {\n  try {\n    // 过滤掉空文本和null值\n    const filteredTexts = texts.filter(text => text && text.trim());\n\n    // 如果没有有效文本需要翻译，直接返回空数组\n    if (filteredTexts.length === 0) {\n      return [];\n    }\n\n    // 获取认证令牌\n    const token = await getAuthToken();\n\n    // 构建URL，只在设置了fromLang时添加from参数\n    const url = `https://api.cognitive.microsofttranslator.com/translate?${fromLang ? `from=${fromLang}&` : ''}to=${toLang}&api-version=3.0`\n\n    // 构建请求数据\n    const data = filteredTexts.map(text => ({ Text: text }));\n\n    // 发送请求\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`\n      },\n      body: JSON.stringify(data)\n    });\n\n    if (!response.ok) {\n      throw new Error(`Tranzy: Translation request failed / 翻译请求失败: ${response.status} ${response.statusText}`);\n    }\n\n    // 处理响应\n    const result = await response.json();\n    return result.map(item => item.translations[0].text);\n  } catch (error) {\n    console.error('Tranzy: Translation request failed / 翻译请求失败', error);\n    throw error;\n  }\n}\n\n/**\n * 检测文本的语言\n * @param {string|string[]} texts - 需要检测语言的文本或文本数组\n * @returns {Promise<Array<{language: string, score: number, isTranslationSupported: boolean, isTransliterationSupported: boolean}>>} - 语言检测结果数组\n */\nexport async function detectLang(texts) {\n  try {\n    // 确保texts是数组\n    const textArray = Array.isArray(texts) ? texts : [texts];\n\n    // 过滤掉空文本和null值\n    const filteredTexts = textArray.filter(text => text && text.trim());\n\n    // 如果没有有效文本需要检测，直接返回空数组\n    if (filteredTexts.length === 0) {\n      return [];\n    }\n\n    // 获取认证令牌\n    const token = await getAuthToken();\n\n    // 构建请求数据\n    const data = filteredTexts.map(text => ({ Text: text }));\n\n    // 发送请求\n    const response = await fetch('https://api.cognitive.microsofttranslator.com/detect?api-version=3.0', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`\n      },\n      body: JSON.stringify(data)\n    });\n\n    if (!response.ok) {\n      throw new Error(`Tranzy: Language detection request failed / 语言检测请求失败: ${response.status} ${response.statusText}`);\n    }\n\n    // 处理响应\n    return await response.json();\n  } catch (error) {\n    console.error('Tranzy: Language detection failed / 语言检测失败', error);\n    throw error;\n  }\n}\n\n/**\n * 获取支持的语种列表\n * @param {string} [displayLang=''] - 用于显示语言名称的BCP 47语言代码，例如：'zh-CN'表示用简体中文显示语言名称\n * @returns {Promise<Object>} - 支持的语种列表，格式为 { languageCode: { name: string, nativeName: string, dir: string } }\n * 注意：所有语言代码均遵循BCP 47规范，例如：'zh-CN'、'en'、'ja'等\n */\nexport async function getSupportedLangs(displayLang = '') {\n  try {\n    // 构建请求头\n    const headers = {\n      'Content-Type': 'application/json'\n    };\n\n    // 如果指定了显示语言，添加到请求头\n    if (displayLang) {\n      headers['Accept-Language'] = displayLang;\n    }\n\n    // 发送请求\n    const response = await fetch('https://api.cognitive.microsofttranslator.com/languages?api-version=3.0', {\n      method: 'GET',\n      headers\n    });\n\n    if (!response.ok) {\n      throw new Error(`Tranzy: Failed to get supported languages / 获取支持语种列表失败: ${response.status} ${response.statusText}`);\n    }\n\n    // 处理响应，只返回translation部分\n    const result = await response.json();\n    return result.translation;\n  } catch (error) {\n    console.error('Tranzy: Failed to get supported languages / 获取支持语种列表失败', error);\n    throw error;\n  }\n}\n\n/**\n * 获取浏览器语言对应的支持语言代码\n * @returns {Promise<string>} - 支持的语言代码，例如：'zh-Hans'、'en'等\n * 注意：返回的语言代码遵循BCP 47规范\n */\nexport async function getBrowserLang() {\n  try {\n    // 获取浏览器语言\n    const browserLang = navigator.language;\n\n    // 获取认证令牌\n    const token = await getAuthToken();\n\n    // 发送请求，翻译空字符串\n    const response = await fetch(`https://api.cognitive.microsofttranslator.com/translate?to=${browserLang}&api-version=3.0`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`\n      },\n      body: JSON.stringify([{ Text: '' }])\n    });\n\n    if (!response.ok) {\n      throw new Error(`Tranzy: Failed to get browser language / 获取浏览器语言失败: ${response.status} ${response.statusText}`);\n    }\n\n    // 处理响应，获取支持的语言代码\n    const result = await response.json();\n    return result[0].translations[0].to;\n  } catch (error) {\n    console.error('Tranzy: Failed to get browser language / 获取浏览器语言失败', error);\n    throw error;\n  }\n}\n\n/**\n * Tranzy核心类\n * 提供页面翻译和DOM变化监听功能\n */\nclass Tranzy {\n  /**\n   * 创建Tranzy实例\n   * @param {Object} config - 配置选项\n   * @param {string} config.toLang - 目标语言代码\n   * @param {string} [config.fromLang=''] - 源语言代码\n   * @param {string[]} [config.ignore=[]] - 忽略的选择器列表\n   * @param {string[]} [config.force=[]] - 强制翻译的选择器列表\n   * @param {string} [config.doneClass='tranzy-done'] - 已翻译元素的标记类\n   * @param {string} [config.pendingClass='tranzy-pending'] - 正在翻译中的元素标记类\n   * @param {number} [config.batch=100] - 批量翻译的批次大小\n   * @param {Function} [config.translatorFn=null] - 自定义翻译函数\n   * @param {Object} [config.manualDict={}] - 手动翻译词典\n   * @param {Function} [config.beforeTranslate=null] - 翻译开始前的钩子\n   * @param {Function} [config.afterTranslate=null] - 翻译结束后的钩子\n   */\n  constructor(config = {}) {\n    // 合并默认配置与用户配置\n    this.config = Object.assign({}, DEFAULT_CONFIG, config);\n\n    // 标准化manualDict配置\n    if (this.config.manualDict) {\n      Object.keys(this.config.manualDict).forEach(lang => {\n        const langDict = this.config.manualDict[lang];\n        Object.keys(langDict).forEach(term => {\n          // 如果翻译值是字符串，转换为标准格式\n          if (typeof langDict[term] === 'string') {\n            langDict[term] = {\n              to: langDict[term],\n              standalone: true,\n              case: true\n            };\n          }\n        });\n      });\n    }\n\n    // 合并并去重忽略选择器\n    this.config.ignore = [...new Set([\n      ...DEFAULT_IGNORE_SELECTORS,\n      ...(this.config.ignore || [])\n    ])];\n\n    // 确保强制翻译选择器是数组\n    this.config.force = this.config.force || [];\n\n    // 将数组选择器合并为字符串选择器，提高性能\n    this.forceSelectorString = this.config.force.length ? this.config.force.join(',') : '';\n    this.ignoreSelectorString = this.config.ignore.length ? this.config.ignore.join(',') : '';\n\n    // 初始化缓存\n    this.cache = new TranslationCache();\n\n    // 初始化状态\n    this.isTranslating = false;         // 是否正在翻译\n    this.pendingElements = new Set();   // 待翻译元素集合\n    this.observer = null;               // DOM观察器实例\n    this.observerConfig = {             // 观察器配置\n      childList: true,                  // 观察子节点变化\n      subtree: true,                    // 观察后代节点变化\n      characterData: true               // 观察文本内容变化\n    };\n  }\n\n  /**\n   * 创建节点过滤器\n   * 用于TreeWalker，决定哪些节点需要被翻译\n   * @returns {Object} - 节点过滤器对象\n   */\n  _createNodeFilter() {\n    return {\n      acceptNode: function (node) {\n        // 跳过已翻译的元素，但允许检查其子元素\n        if (node.classList.contains(this.config.doneClass)) {\n          return NodeFilter.FILTER_SKIP;\n        }\n\n        // 优先级1：检查当前节点是否匹配force选择器\n        if (this.forceSelectorString && node.matches(this.forceSelectorString)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        // 优先级2：检查父节点是否匹配force选择器\n        if (this.forceSelectorString) {\n          let parent = node.parentNode;\n          while (parent && parent !== document) {\n            if (parent.matches(this.forceSelectorString)) {\n              return NodeFilter.FILTER_ACCEPT;\n            }\n            parent = parent.parentNode;\n          }\n        }\n\n        // 优先级3：检查子节点是否匹配force选择器\n        let hasForceChild = false;\n        if (this.forceSelectorString && node.children.length > 0) {\n          hasForceChild = node.querySelector(this.forceSelectorString);\n        }\n\n        // 优先级4：检查当前节点是否匹配ignore选择器\n        if (this.ignoreSelectorString && node.matches(this.ignoreSelectorString)) {\n          return hasForceChild ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;\n        }\n\n        // 优先级5：检查父节点是否匹配ignore选择器\n        if (this.ignoreSelectorString) {\n          let parent = node.parentNode;\n          while (parent && parent !== document) {\n            if (parent.matches(this.ignoreSelectorString)) {\n              return hasForceChild ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;\n            }\n            parent = parent.parentNode;\n          }\n        }\n\n        // 默认接受：如果以上所有条件都不满足，接受节点进行翻译\n        return NodeFilter.FILTER_ACCEPT;\n      }.bind(this)\n    };\n  }\n\n  /**\n   * 开始观察DOM变化\n   * @param {string} [root='body'] - 观察的根元素选择器\n   * @returns {Tranzy} - 当前实例，支持链式调用\n   */\n  startObserver(root = 'body') {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n\n    this.observer = new MutationObserver((mutations) => {\n      let shouldTranslate = false;\n      for (const mutation of mutations) {\n        // 处理新增节点\n        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n          mutation.addedNodes.forEach(node => {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n              // 使用TreeWalker遍历所有元素节点\n              const treeWalker = document.createTreeWalker(\n                node,\n                NodeFilter.SHOW_ELEMENT,\n                this._createNodeFilter()\n              );\n\n              // 收集所有符合条件的元素\n              let currentNode;\n              while (currentNode = treeWalker.nextNode()) {\n                this.pendingElements.add(currentNode);\n                shouldTranslate = true;\n              }\n            }\n          });\n        }\n\n        // 处理文本变化\n        if (mutation.type === 'characterData') {\n          const node = mutation.target.parentNode;\n          if (node && node.nodeType === Node.ELEMENT_NODE) {\n            // 检查节点是否正在翻译中\n            if (node.classList.contains(this.config.pendingClass)) {\n              continue;\n            }\n\n            // 检查所有父元素，如果有任何父元素被忽略且不在强制翻译列表中，则跳过\n            let shouldSkip = false;\n            let parent = node;\n\n            while (parent) {\n              if (this.ignoreSelectorString && parent.matches(this.ignoreSelectorString) &&\n                !(this.forceSelectorString && parent.matches(this.forceSelectorString))) {\n                shouldSkip = true;\n                break;\n              }\n              parent = parent.parentNode;\n              if (!parent || parent === document) break;\n            }\n\n            if (!shouldSkip) {\n              this.pendingElements.add(node);\n              shouldTranslate = true;\n            }\n          }\n        }\n      }\n\n      if (shouldTranslate) {\n        // 直接翻译\n        this._translatePending();\n      }\n    });\n\n    this.observer.observe(document.querySelector(root), this.observerConfig);\n\n    return this;\n  }\n\n  /**\n   * 停止观察DOM变化\n   * @returns {Tranzy} - 当前实例，支持链式调用\n   */\n  stopObserver() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n\n    return this;\n  }\n\n  /**\n   * 翻译待处理元素\n   * @param {boolean} [again=false] - 是否是重复翻译\n   * @private\n   */\n  async _translatePending(again = false) {\n    if (this.pendingElements.size === 0 || this.isTranslating) {\n      return;\n    }\n\n    if (!again && typeof this.config.beforeTranslate === 'function') {\n      this.config.beforeTranslate();\n    }\n\n    this.isTranslating = true;\n\n    const elements = Array.from(this.pendingElements);\n    this.pendingElements.clear();\n\n    await this._translateElements(elements);\n\n    this.isTranslating = false;\n\n    // 检查是否有新的待处理元素\n    if (this.pendingElements.size > 0) {\n      this._translatePending(true);\n    } else {\n      if (typeof this.config.afterTranslate === 'function') {\n        this.config.afterTranslate();\n      }\n    }\n  }\n\n  /**\n   * 翻译整个页面\n   * @param {string} [root='body'] - 翻译的根元素选择器\n   * @returns {Promise<Tranzy>} - 当前实例，支持链式调用\n   */\n  async translatePage(root = 'body') {\n    if (this.isTranslating) {\n      return;\n    }\n\n    this.isTranslating = true;\n\n    // 临时停止观察器，避免翻译过程中触发更多的变化\n    const wasObserving = !!this.observer;\n    if (wasObserving) {\n      this.stopObserver();\n    }\n\n    // 执行beforeTranslate钩子\n    if (typeof this.config.beforeTranslate === 'function') {\n      this.config.beforeTranslate();\n    }\n\n    try {\n      // 使用TreeWalker获取所有需要翻译的元素\n      const elements = [];\n      const rootElement = document.querySelector(root);\n\n      // 创建TreeWalker，只显示元素节点\n      const treeWalker = document.createTreeWalker(\n        rootElement,\n        NodeFilter.SHOW_ELEMENT,\n        this._createNodeFilter()\n      );\n\n      // 收集所有符合条件的元素\n      let node;\n      while (node = treeWalker.nextNode()) {\n        elements.push(node);\n      }\n\n      await this._translateElements(elements);\n    } catch (error) {\n      console.error('Tranzy: Page translation failed / 页面翻译失败', error);\n    } finally {\n      // 执行afterTranslate钩子\n      if (typeof this.config.afterTranslate === 'function') {\n        this.config.afterTranslate();\n      }\n\n      this.isTranslating = false;\n\n      // 如果之前在观察，重新启动观察器\n      if (wasObserving) {\n        this.startObserver(root);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * 翻译元素数组\n   * @param {Element[]} elements - 需要翻译的元素数组\n   * @private\n   */\n  async _translateElements(elements) {\n    // 过滤出需要翻译的元素并保存文本\n    const validElements = [];\n    const elementsText = [];\n\n    for (const el of elements) {\n      const text = this._getElementText(el);\n      if (text) {\n        validElements.push(el);\n        elementsText.push(text);\n      }\n    }\n\n    if (validElements.length === 0) {\n      return;\n    }\n\n    // 批量处理元素\n    const batchSize = this.config.batch;\n    for (let i = 0; i < validElements.length; i += batchSize) {\n      const batchElements = validElements.slice(i, i + batchSize);\n      const batchTexts = elementsText.slice(i, i + batchSize);\n      await this._translateElementBatch(batchElements, batchTexts);\n    }\n  }\n\n  /**\n   * 检查文本中是否包含术语并拆分\n   * @param {string} text - 需要检查的文本\n   * @returns {string[]} - 拆分后的文本数组\n   * @private\n   */\n  _splitByTerms(text) {\n    const toLangDict = this.config.manualDict[this.config.toLang];\n    if (!toLangDict) return [text];\n\n    // 按长度降序排序术语，优先匹配最长的术语\n    const terms = Object.keys(toLangDict).sort((a, b) => b.length - a.length);\n\n    // 先检查是否有完全匹配的术语\n    for (const term of terms) {\n      const translation = toLangDict[term];\n      // 如果是独立匹配模式（默认为true）且文本完全等于术语\n      if ((translation.standalone !== false) &&\n        (translation.case === false ? text.toLowerCase() === term.toLowerCase() : text === term)) {\n        return [text];\n      }\n    }\n\n    // 如果没有完全匹配，且文本中没有包含任何术语，直接返回原文本\n    let containsAnyTerm = false;\n    for (const term of terms) {\n      const translation = toLangDict[term];\n      if (translation.case === false ?\n        text.toLowerCase().includes(term.toLowerCase()) :\n        text.includes(term)) {\n        containsAnyTerm = true;\n        break;\n      }\n    }\n\n    if (!containsAnyTerm) {\n      return [text];\n    }\n\n    // 拆分文本\n    const parts = [];\n    let currentText = text;\n\n    while (currentText.length > 0) {\n      let foundTerm = false;\n      for (const term of terms) {\n        const translation = toLangDict[term];\n        // 跳过需要独立匹配的术语\n        if (translation.standalone !== false) {\n          continue;\n        }\n\n        // 使用正则表达式匹配术语，根据case配置决定是否忽略大小写\n        const flags = translation.case === false ? 'gi' : 'g';\n        const termRegex = new RegExp(`\\\\b${term}\\\\b`, flags);\n        const match = termRegex.exec(currentText);\n\n        if (match) {\n          const index = match.index;\n          // 如果术语前面有文本，添加为一部分\n          if (index > 0) {\n            parts.push(currentText.substring(0, index));\n          }\n          // 添加术语\n          parts.push(term);\n          // 更新剩余文本\n          currentText = currentText.substring(index + term.length);\n          foundTerm = true;\n          break;\n        }\n      }\n      // 如果没有找到术语，将剩余文本作为一部分\n      if (!foundTerm) {\n        parts.push(currentText);\n        break;\n      }\n    }\n\n    return parts;\n  }\n\n  /**\n   * 批量翻译元素\n   * @param {Element[]} elements - 需要翻译的元素数组\n   * @param {string[]} textsArray - 对应的文本数组\n   * @private\n   */\n  async _translateElementBatch(elements, textsArray) {\n    // 收集需要翻译的文本和对应的元素\n    const elementsWithText = [];\n    let textsToTranslate = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      const text = textsArray[i];\n\n      // 将元素和文本添加到待处理列表\n      elementsWithText.push(element);\n      textsToTranslate.push(text);\n      // 标记元素为正在翻译状态，防止重复处理\n      element.classList.add(this.config.pendingClass);\n    }\n\n    if (textsToTranslate.length === 0) {\n      return;\n    }\n\n    // 创建元素到其直接文本节点的映射表\n    const nodeTextMap = new Map();\n\n    // 预处理每个元素，收集其直接文本节点\n    for (let i = 0; i < elementsWithText.length; i++) {\n      const element = elementsWithText[i];\n\n      // 如果元素包含子元素，需要单独处理每个文本节点\n      if (element.childElementCount > 0) {\n        // 收集元素的直接文本节点（不包含子元素的文本节点）\n        const textNodes = [];\n        const treeWalker = document.createTreeWalker(\n          element,\n          NodeFilter.SHOW_TEXT,\n          {\n            acceptNode: function (node) {\n              // 只接受直接子文本节点，跳过深层文本节点\n              if (node.parentNode !== element) {\n                return NodeFilter.FILTER_SKIP;\n              }\n              return NodeFilter.FILTER_ACCEPT;\n            }\n          }\n        );\n\n        let node;\n        while (node = treeWalker.nextNode()) {\n          const text = node.textContent;\n          const trimmed = text.trim();\n          if (trimmed) {\n            // 保存文本节点的完整信息，包括前后空格\n            textNodes.push({\n              node,\n              text: trimmed,\n              leadingSpaces: text.match(/^\\s*/)[0],\n              trailingSpaces: text.match(/\\s*$/)[0]\n            });\n          }\n        }\n\n        // 如果元素包含多个文本节点，需要特殊处理\n        if (textNodes.length > 1) {\n          // 存储元素到其文本节点的映射关系，用于后续处理\n          nodeTextMap.set(element, textNodes);\n\n          // 为每个文本节点创建独立的翻译任务\n          textNodes.forEach(nodeInfo => {\n            textsToTranslate.push(nodeInfo.text);\n            elementsWithText.push({\n              isTextNode: true,\n              nodeInfo\n            });\n          });\n\n          // 标记原始元素的翻译任务为跳过，因为已经为每个文本节点创建了独立任务\n          textsToTranslate[i] = null;\n        }\n      }\n    }\n\n    // 过滤掉被标记为跳过的元素和文本\n    const validElementTexts = elementsWithText.filter((_, i) => textsToTranslate[i] !== null);\n    const validTexts = textsToTranslate.filter(text => text !== null);\n\n    // 用术语替换处理每个文本\n    const termProcessedTexts = [];\n    const termMappings = new Map();\n\n    for (const text of validTexts) {\n      if (!text) continue;\n\n      // 检查文本中是否包含术语\n      const parts = this._splitByTerms(text);\n\n      // 如果被拆分，需要单独处理每个部分\n      if (parts.length > 1) {\n        termMappings.set(text, parts);\n        parts.forEach(part => termProcessedTexts.push(part));\n      } else {\n        termProcessedTexts.push(text);\n      }\n    }\n\n    // 去重以减少翻译请求\n    const uniqueTextsToTranslate = [...new Set(termProcessedTexts)];\n\n    // 检查手动词典和缓存\n    const manualTranslations = {};\n    const textsToBeCached = [];\n    const textsToFetch = [];\n\n    for (const text of uniqueTextsToTranslate) {\n      // 检查手动词典\n      const toLangDict = this.config.manualDict[this.config.toLang];\n      const translation = toLangDict && (\n        toLangDict[text] ||\n        (toLangDict[text.toLowerCase()]?.case === false ? toLangDict[text.toLowerCase()] : null)\n      );\n\n      if (translation) {\n        manualTranslations[text] = translation.to;\n      } else {\n        // 检查缓存\n        const cachedTranslation = await this.cache.get(text, this.config.toLang, this.config.fromLang);\n        if (cachedTranslation) {\n          manualTranslations[text] = cachedTranslation;\n        } else {\n          textsToBeCached.push(text);\n          textsToFetch.push(text);\n        }\n      }\n    }\n\n    // 翻译未缓存的文本\n    if (textsToFetch.length > 0) {\n      try {\n        const apiResults = await this.config.translatorFn(textsToFetch, this.config.toLang, this.config.fromLang);\n        console.log('apiResults', apiResults);\n\n        // 更新缓存\n        await this.cache.setBatch(textsToFetch, apiResults, this.config.toLang, this.config.fromLang);\n\n        // 合并翻译结果\n        textsToFetch.forEach((text, index) => {\n          manualTranslations[text] = apiResults[index];\n        });\n      } catch (error) {\n        console.error('Tranzy: Batch translation failed / 批量翻译失败', error);\n        textsToFetch.forEach(text => {\n          manualTranslations[text] = text; // 错误时保持原文\n        });\n      }\n    }\n\n    // 构建最终翻译映射\n    const finalTranslations = new Map();\n\n    // 首先处理被术语拆分的文本\n    for (const [originalText, parts] of termMappings.entries()) {\n      const translatedParts = parts.map(part => manualTranslations[part] || part);\n      finalTranslations.set(originalText, translatedParts.join(''));\n    }\n\n    // 然后处理未被拆分的文本\n    for (const text of validTexts) {\n      if (!text || termMappings.has(text)) continue;\n      finalTranslations.set(text, manualTranslations[text] || text);\n    }\n\n    // 应用翻译结果\n    validElementTexts.forEach((element, index) => {\n      const originalText = validTexts[index];\n      if (!originalText) return;\n\n      const translatedText = finalTranslations.get(originalText);\n      if (!translatedText) return;\n\n      // 处理文本节点\n      if (element.isTextNode) {\n        const { node, leadingSpaces, trailingSpaces } = element.nodeInfo;\n        node.textContent = leadingSpaces + translatedText + trailingSpaces;\n\n        // 检查父元素是否已经处理完所有子节点\n        const parentElement = node.parentNode;\n        if (parentElement) {\n          // 等待下一个微任务，确保DOM更新完成\n          queueMicrotask(() => {\n            parentElement.classList.remove(this.config.pendingClass);\n            parentElement.classList.add(this.config.doneClass);\n          });\n        }\n      } else {\n        // 如果是简单元素(没有被分解为单独节点)，直接应用翻译\n        if (!nodeTextMap.has(element)) {\n          this._applyTranslation(element, originalText, translatedText);\n          // 等待下一个微任务，确保DOM更新完成\n          queueMicrotask(() => {\n            element.classList.remove(this.config.pendingClass);\n            element.classList.add(this.config.doneClass);\n          });\n        } else {\n          // 已经单独处理了各个文本节点，只需标记为已翻译\n          // 等待下一个微任务，确保DOM更新完成\n          queueMicrotask(() => {\n            element.classList.remove(this.config.pendingClass);\n            element.classList.add(this.config.doneClass);\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * 获取元素文本内容\n   * @param {Element} element - 需要获取文本的元素\n   * @returns {string|null} - 元素的文本内容，如果没有有效文本则返回null\n   * @private\n   */\n  _getElementText(element) {\n    // 使用TreeWalker遍历元素的所有文本节点\n    let textContent = '';\n    const treeWalker = document.createTreeWalker(\n      element,\n      NodeFilter.SHOW_TEXT,\n      {\n        acceptNode: function (node) {\n          // 只获取直接的文本节点，跳过深层元素内的文本\n          if (node.parentNode !== element) {\n            return NodeFilter.FILTER_SKIP;\n          }\n          return NodeFilter.FILTER_ACCEPT;\n        }\n      }\n    );\n\n    let node;\n    while (node = treeWalker.nextNode()) {\n      const text = node.textContent.trim();\n      if (text) {\n        textContent += text + ' ';\n      }\n    }\n\n    textContent = textContent.trim();\n\n    // 如果是空文本，直接返回null\n    if (!textContent || /^\\s*$/.test(textContent)) {\n      return null;\n    }\n\n    // 过滤掉只包含数字、空格、回车、特殊字符的文本\n    // 但保留包含中文、英文、数字的文本\n    if (/^[\\s\\d\\p{P}\\p{S}]+$/u.test(textContent) && !/[\\p{L}\\u4e00-\\u9fa5]/.test(textContent)) {\n      return null;\n    }\n\n    return textContent;\n  }\n\n  /**\n   * 应用翻译结果到元素\n   * @param {Element} element - 需要应用翻译的元素\n   * @param {string} originalText - 原始文本\n   * @param {string} translatedText - 翻译后的文本\n   * @private\n   */\n  _applyTranslation(element, originalText, translatedText) {\n    if (!translatedText || originalText === translatedText) {\n      return;\n    }\n\n    // 标记已翻译\n    element.classList.add(this.config.doneClass);\n\n    // 如果元素有子元素，只替换直接的文本节点\n    if (element.childElementCount > 0) {\n      // 1. 收集所有直接文本节点信息\n      const textNodes = [];\n      const treeWalker = document.createTreeWalker(\n        element,\n        NodeFilter.SHOW_TEXT,\n        {\n          acceptNode: function (node) {\n            if (node.parentNode !== element) {\n              return NodeFilter.FILTER_SKIP;\n            }\n            return NodeFilter.FILTER_ACCEPT;\n          }\n        }\n      );\n\n      let node;\n      while (node = treeWalker.nextNode()) {\n        const text = node.textContent;\n        const trimmed = text.trim();\n        if (trimmed) {\n          textNodes.push({\n            node,\n            text: trimmed,\n            leadingSpaces: text.match(/^\\s*/)[0],\n            trailingSpaces: text.match(/\\s*$/)[0]\n          });\n        }\n      }\n\n      // 如果没有文本节点或只有一个文本节点，简单处理\n      if (textNodes.length === 0) {\n        return;\n      } else if (textNodes.length === 1) {\n        const { node, leadingSpaces, trailingSpaces } = textNodes[0];\n        node.textContent = leadingSpaces + translatedText + trailingSpaces;\n        return;\n      }\n\n      // 注意：多文本节点的情况已在_translateElementBatch中处理\n      // 这里作为备用方案，使用简单的按比例分配\n      const totalTextLength = textNodes.reduce((sum, item) => sum + item.text.length, 0);\n      let usedTranslationLength = 0;\n\n      textNodes.forEach((item, index) => {\n        const { node, text, leadingSpaces, trailingSpaces } = item;\n        let nodeTranslation;\n\n        if (index === textNodes.length - 1) {\n          // 最后一个节点使用剩余的所有翻译文本\n          nodeTranslation = translatedText.substring(usedTranslationLength);\n        } else {\n          // 计算当前节点文本在原始完整文本中的占比\n          const ratio = text.length / totalTextLength;\n          // 根据比例计算应该分配的翻译文本长度\n          const translationLength = Math.round(translatedText.length * ratio);\n\n          // 从当前位置提取对应长度的翻译文本\n          nodeTranslation = translatedText.substring(\n            usedTranslationLength,\n            usedTranslationLength + translationLength\n          );\n\n          // 更新已使用的翻译文本长度\n          usedTranslationLength += translationLength;\n        }\n\n        // 应用翻译结果到文本节点，保留原始空格\n        node.textContent = leadingSpaces + nodeTranslation + trailingSpaces;\n      });\n    } else {\n      // 如果没有子元素，保留原始文本中的空格\n      const leadingSpaces = element.textContent.match(/^\\s*/)[0];\n      const trailingSpaces = element.textContent.match(/\\s*$/)[0];\n      element.textContent = leadingSpaces + translatedText + trailingSpaces;\n    }\n  }\n\n  /**\n   * 销毁实例，释放资源\n   * @returns {Tranzy} - 当前实例，支持链式调用\n   */\n  destroy() {\n    // 停止DOM观察器\n    this.stopObserver();\n\n    // 清空待处理元素\n    this.pendingElements.clear();\n\n    // 关闭数据库连接\n    if (this.cache && this.cache.db) {\n      this.cache.db.close();\n      this.cache.db = null;\n    }\n\n    // 重置状态\n    this.isTranslating = false;\n\n    return this;\n  }\n}\n\nexport default Tranzy; "],"names":["DEFAULT_IGNORE_SELECTORS","DEFAULT_CONFIG","toLang","navigator","language","fromLang","ignore","force","doneClass","pendingClass","batch","translatorFn","translateText","manualDict","beforeTranslate","afterTranslate","TranslationCache","constructor","this","dbName","storeName","db","initPromise","_initDatabase","_generateHash","str","hash","i","length","charCodeAt","toString","Promise","resolve","reject","request","indexedDB","open","onupgradeneeded","event","target","result","objectStoreNames","contains","createObjectStore","keyPath","onsuccess","onerror","error","get","text","id","transaction","objectStore","value","set","translation","put","getBatch","texts","results","Array","fill","remainingIndices","all","map","async","index","cachedTranslation","push","setBatch","translations","clearTokenFromSession","sessionStorage","removeItem","getAuthToken","now","Date","token","timestamp","tokenData","getItem","JSON","parse","loadTokenFromSession","response","fetch","method","headers","ok","Error","status","statusText","newToken","setItem","stringify","saveTokenToSession","filteredTexts","filter","trim","url","data","Text","Authorization","body","json","item","config","Object","assign","keys","forEach","lang","langDict","term","to","standalone","case","Set","forceSelectorString","join","ignoreSelectorString","cache","isTranslating","pendingElements","observer","observerConfig","childList","subtree","characterData","_createNodeFilter","acceptNode","node","classList","NodeFilter","FILTER_SKIP","matches","FILTER_ACCEPT","parent","parentNode","document","hasForceChild","children","querySelector","FILTER_REJECT","bind","startObserver","root","disconnect","MutationObserver","mutations","shouldTranslate","mutation","type","addedNodes","nodeType","Node","ELEMENT_NODE","treeWalker","createTreeWalker","SHOW_ELEMENT","currentNode","nextNode","add","shouldSkip","_translatePending","observe","stopObserver","again","size","elements","from","clear","_translateElements","translatePage","wasObserving","rootElement","validElements","elementsText","el","_getElementText","batchSize","batchElements","slice","batchTexts","_translateElementBatch","_splitByTerms","toLangDict","terms","sort","a","b","toLowerCase","containsAnyTerm","includes","parts","currentText","foundTerm","flags","match","RegExp","exec","substring","textsArray","elementsWithText","textsToTranslate","element","nodeTextMap","Map","childElementCount","textNodes","SHOW_TEXT","textContent","trimmed","leadingSpaces","trailingSpaces","nodeInfo","isTextNode","validElementTexts","_","validTexts","termProcessedTexts","termMappings","part","uniqueTextsToTranslate","manualTranslations","textsToFetch","apiResults","finalTranslations","originalText","entries","translatedParts","has","translatedText","parentElement","queueMicrotask","remove","_applyTranslation","test","totalTextLength","reduce","sum","usedTranslationLength","nodeTranslation","ratio","translationLength","Math","round","destroy","close","isArray","browserLang","displayLang"],"mappings":"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"}