{"version":3,"file":"tranzy.umd.js","sources":["../src/tranzy.js"],"sourcesContent":["/**\n * Tranzy - 网页自动翻译插件\n * 支持自动检测DOM更新并翻译新增元素\n * 使用微软翻译API实现多语言翻译\n * 同时支持ESM和浏览器直接使用\n *\n * @author Fts Cloud <ftsuperb@vip.qq.com>\n * @license MIT\n * @repository https://github.com/FtsCloud/Tranzy\n * @copyright Copyright (c) 2023-present Fts Cloud\n */\n\n// 默认忽略的选择器列表，这些元素及其内容不会被翻译\nconst DEFAULT_IGNORE_SELECTORS = [\n  'style',            // 样式标签\n  'script',           // 脚本标签\n  'noscript',         // 无脚本标签\n  'code',             // 代码标签\n  'pre',              // 预格式化文本标签\n  'input',            // 输入框\n  'textarea',         // 文本域\n  '[contenteditable=\"true\"]', // 可编辑元素\n  '.tranzy-ignore'    // 自定义忽略类\n];\n\n// 默认配置选项\nconst DEFAULT_CONFIG = {\n  toLang: navigator.language || '',    // 目标语言，默认从浏览器语言设置获取，如果没有则使用中文\n  fromLang: '',                        // 源语言，如：'en'\n  root: 'body',                        // 要翻译的根元素\n  ignore: [],                          // 自定义忽略选择器列表\n  force: [],                           // 强制翻译选择器列表\n  doneClass: 'tranzy-done',            // 已翻译元素的标记类\n  pendingClass: 'tranzy-pending',      // 正在翻译中的元素标记类\n  auto: false,                         // 是否自动监听DOM变化\n  batch: 100,                          // 批量翻译时的批次大小\n  translator: null,                    // 自定义翻译器实例\n  manualDict: {},                      // 手动翻译词典\n  hooks: {                             // 生命周期钩子函数\n    before: null,                      // 翻译开始前的钩子\n    after: null,                       // 翻译结束后的钩子\n    beforeElement: null,               // 翻译单个元素前的钩子\n    afterElement: null,                // 翻译单个元素后的钩子\n  }\n};\n\n// 辅助函数：深度合并对象，支持数组去重\nfunction mergeDeep(...objects) {\n  return objects.reduce((prev, obj) => {\n    Object.keys(obj).forEach(key => {\n      const pVal = prev[key];\n      const oVal = obj[key];\n\n      if (Array.isArray(pVal) && Array.isArray(oVal)) {\n        // 数组类型进行合并并去重\n        prev[key] = Array.from(new Set([...pVal, ...oVal]));\n      } else if (isObject(pVal) && isObject(oVal)) {\n        // 对象类型进行递归合并\n        prev[key] = mergeDeep(pVal, oVal);\n      } else {\n        // 其他类型直接覆盖\n        prev[key] = oVal;\n      }\n    });\n\n    return prev;\n  }, {});\n}\n\n// 辅助函数：检查值是否为对象（非null且非数组）\nfunction isObject(item) {\n  return (item && typeof item === 'object' && !Array.isArray(item));\n}\n\n// IndexedDB缓存管理器：用于存储翻译结果，提高性能\nclass TranslationCache {\n  constructor() {\n    this.dbName = 'tranzy-cache';      // 数据库名称\n    this.storeName = 'translations';    // 存储对象名称\n    this.db = null;                     // 数据库实例\n    this.initPromise = this._initDatabase(); // 初始化Promise\n  }\n\n  // 生成字符串哈希值，用于缓存键\n  _generateHash(str) {\n    let hash = 2166136261;\n    for (let i = 0; i < str.length; i++) {\n      hash ^= str.charCodeAt(i);\n      hash *= 16777619;\n    }\n    return hash.toString(36);  // 使用base36编码，生成更短的哈希值\n  }\n\n  // 初始化IndexedDB数据库\n  async _initDatabase() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, 1);\n\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          const store = db.createObjectStore(this.storeName, { keyPath: 'id' });\n        }\n      };\n\n      request.onsuccess = (event) => {\n        this.db = event.target.result;\n        resolve();\n      };\n\n      request.onerror = (event) => {\n        console.error('Tranzy: 初始化缓存数据库失败', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  }\n\n  // 获取缓存的翻译结果\n  async get(text, toLang, fromLang = '') {\n    await this.initPromise;\n    const id = this._generateHash(`${text}|${toLang}|${fromLang}`);\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve(null);\n        return;\n      }\n\n      const transaction = this.db.transaction(this.storeName, 'readonly');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.get(id);\n\n      request.onsuccess = (event) => {\n        resolve(event.target.result?.value || null);\n      };\n\n      request.onerror = () => {\n        resolve(null);\n      };\n    });\n  }\n\n  // 设置翻译结果到缓存\n  async set(text, translation, toLang, fromLang = '') {\n    await this.initPromise;\n    const id = this._generateHash(`${text}|${toLang}|${fromLang}`);\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve();\n        return;\n      }\n\n      const transaction = this.db.transaction(this.storeName, 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.put({\n        id,\n        value: translation\n      });\n\n      request.onsuccess = () => {\n        resolve();\n      };\n\n      request.onerror = () => {\n        resolve();\n      };\n    });\n  }\n\n  // 批量获取缓存的翻译结果\n  async getBatch(texts, toLang, fromLang = '') {\n    await this.initPromise;\n    const results = Array(texts.length).fill(null);\n    const remainingIndices = [];\n\n    await Promise.all(texts.map(async (text, index) => {\n      const cachedTranslation = await this.get(text, toLang, fromLang);\n      if (cachedTranslation) {\n        results[index] = cachedTranslation;\n      } else {\n        remainingIndices.push(index);\n      }\n    }));\n\n    return {\n      results,\n      remainingIndices\n    };\n  }\n\n  // 批量设置翻译结果到缓存\n  async setBatch(texts, translations, toLang, fromLang = '') {\n    await this.initPromise;\n    await Promise.all(texts.map((text, index) => {\n      return this.set(text, translations[index], toLang, fromLang);\n    }));\n  }\n}\n\n// 默认微软翻译API实现\nclass MicrosoftTranslator {\n  constructor(fromLang = '') {\n    this.fromLang = fromLang;\n    this.tokenExpireMinutes = 10; // token过期时间（分钟）\n    this._loadTokenFromSession();\n  }\n\n  // 从sessionStorage加载token\n  _loadTokenFromSession() {\n    try {\n      const tokenData = sessionStorage.getItem('tranzy_auth_token');\n      if (tokenData) {\n        const { token, timestamp } = JSON.parse(tokenData);\n        const now = Date.now();\n        // 如果token未过期，则使用缓存的token\n        if (token && (now - timestamp) < this.tokenExpireMinutes * 60 * 1000) {\n          this.authToken = token;\n          this.tokenTimestamp = timestamp;\n        } else {\n          // token已过期，清除缓存\n          this._clearTokenFromSession();\n        }\n      }\n    } catch (error) {\n      console.error('Tranzy: 从session加载token失败', error);\n      this._clearTokenFromSession();\n    }\n  }\n\n  // 保存token到sessionStorage\n  _saveTokenToSession(token, timestamp) {\n    try {\n      sessionStorage.setItem('tranzy_auth_token', JSON.stringify({ token, timestamp }));\n    } catch (error) {\n      console.error('Tranzy: 保存token到session失败', error);\n    }\n  }\n\n  // 清除sessionStorage中的token\n  _clearTokenFromSession() {\n    try {\n      sessionStorage.removeItem('tranzy_auth_token');\n      this.authToken = null;\n      this.tokenTimestamp = 0;\n    } catch (error) {\n      console.error('Tranzy: 清除session中的token失败', error);\n    }\n  }\n\n  // 获取微软翻译API的认证token\n  async getAuthToken() {\n    const now = Date.now();\n\n    // 如果token获取时间小于10分钟，则直接返回\n    if (this.authToken && (now - this.tokenTimestamp) < this.tokenExpireMinutes * 60 * 1000) {\n      return this.authToken;\n    }\n\n    try {\n      const response = await fetch('https://edge.microsoft.com/translate/auth', {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`获取微软翻译授权失败: ${response.status} ${response.statusText}`);\n      }\n\n      const token = await response.text();\n      this.tokenTimestamp = now;\n      this.authToken = token;\n      \n      // 保存token到session\n      this._saveTokenToSession(token, now);\n      \n      return token;\n    } catch (error) {\n      console.error('Tranzy: 获取微软翻译授权失败', error);\n      this._clearTokenFromSession();\n      throw error;\n    }\n  }\n\n  // 调用微软翻译API进行翻译\n  async translate(texts, toLang) {\n    try {\n      // 过滤掉空文本和null值\n      const filteredTexts = texts.filter(text => text && text.trim());\n\n      // 如果没有有效文本需要翻译，直接返回空数组\n      if (filteredTexts.length === 0) {\n        return [];\n      }\n\n      // 获取认证令牌\n      const token = await this.getAuthToken();\n\n      // 构建URL，只在设置了fromLang时添加from参数\n      const url = `https://api.cognitive.microsofttranslator.com/translate?${this.fromLang?`from=${this.fromLang}&`:''}to=${toLang}&api-version=3.0`\n        \n\n      // 构建请求数据\n      const data = filteredTexts.map(text => ({ Text: text }));\n\n      // 发送请求\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify(data)\n      });\n\n      if (!response.ok) {\n        throw new Error(`翻译请求失败: ${response.status} ${response.statusText}`);\n      }\n\n      // 处理响应\n      const result = await response.json();\n      return result.map(item => item.translations[0].text);\n    } catch (error) {\n      console.error('Tranzy: 翻译请求失败', error);\n      throw error;\n    }\n  }\n}\n\n// Tranzy核心类\nclass Tranzy {\n  constructor(config = {}) {\n    // 合并默认配置与用户配置\n    this.config = mergeDeep({}, DEFAULT_CONFIG, config);\n\n    // 标准化manualDict配置\n    if (this.config.manualDict) {\n      Object.keys(this.config.manualDict).forEach(lang => {\n        const langDict = this.config.manualDict[lang];\n        Object.keys(langDict).forEach(term => {\n          // 如果翻译值是字符串，转换为标准格式\n          if (typeof langDict[term] === 'string') {\n            langDict[term] = {\n              to: langDict[term],\n              standalone: true,\n              case: true\n            };\n          }\n        });\n      });\n    }\n\n    // 初始化缓存\n    this.cache = new TranslationCache();\n\n    // 初始化翻译器，传入用户配置的fromLang\n    this.translator = this.config.translator || new MicrosoftTranslator(this.config.fromLang);\n\n    // 初始化状态\n    this.isTranslating = false;         // 是否正在翻译\n    this.pendingElements = new Set();   // 待翻译元素集合\n    this.observer = null;               // DOM观察器实例\n    this.observerConfig = {             // 观察器配置\n      childList: true,                  // 观察子节点变化\n      subtree: true                     // 观察后代节点变化\n    };\n    \n    // 初始化选择器字符串\n    this.forceSelectorString = '';      // 强制翻译选择器字符串\n    this.ignoreSelectorString = '';     // 忽略选择器字符串\n  }\n\n  // 创建节点过滤器\n  _createNodeFilter() {\n    return {\n      acceptNode: function (node) {\n        // 跳过已翻译的元素\n        if (node.classList.contains(this.config.doneClass)) {\n          return NodeFilter.FILTER_SKIP; // 改为SKIP，允许检查子元素\n        }\n\n        // 第一步：检查当前节点是否匹配force选择器\n        if (this.forceSelectorString && node.matches(this.forceSelectorString)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n          \n        // 第二步：检查父节点是否匹配force选择器\n        if (this.forceSelectorString) {\n          let parent = node.parentNode;\n          while (parent && parent !== document) {\n            if (parent.matches(this.forceSelectorString)) {\n              return NodeFilter.FILTER_ACCEPT;\n            }\n            parent = parent.parentNode;\n          }\n        }\n        \n        // 第三步：检查子节点是否有任何一个匹配force选择器\n        // 如果有，我们不应该直接接受当前节点，而是标记为SKIP\n        // 这样TreeWalker会继续检查子节点，那些匹配force的子节点会被单独接受\n        if (this.forceSelectorString && node.children.length > 0) {\n          // 使用querySelector检查是否有子节点匹配force选择器\n          const hasForceChild = node.querySelector(this.forceSelectorString);\n          if (hasForceChild) {\n            // 跳过当前节点，让TreeWalker继续检查其子节点\n            return NodeFilter.FILTER_SKIP;\n          }\n        }\n        \n        // 第四步：检查当前节点是否匹配ignore选择器\n        if (this.ignoreSelectorString && node.matches(this.ignoreSelectorString)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n        \n        // 第五步：检查父节点是否匹配ignore选择器\n        if (this.ignoreSelectorString) {\n          let parent = node.parentNode;\n          while (parent && parent !== document) {\n            if (parent.matches(this.ignoreSelectorString)) {\n              return NodeFilter.FILTER_REJECT;\n            }\n            parent = parent.parentNode;\n          }\n        }\n\n        // 默认接受节点进行翻译\n        return NodeFilter.FILTER_ACCEPT;\n      }.bind(this)\n    };\n  }\n\n  // 翻译页面并初始化插件\n  translate() {\n    // 合并并去重忽略选择器\n    this.config.ignore = [...new Set([\n      ...DEFAULT_IGNORE_SELECTORS,\n      ...(this.config.ignore || [])\n    ])];\n\n    // 确保强制翻译选择器是数组\n    this.config.force = this.config.force || [];\n    \n    // 将数组选择器合并为字符串选择器，提高性能\n    this.forceSelectorString = this.config.force.length ? this.config.force.join(',') : '';\n    this.ignoreSelectorString = this.config.ignore.length ? this.config.ignore.join(',') : '';\n\n    // 先进行一次初始翻译\n    this.translatePage();\n\n    // 如果配置了自动监听，则开始监听DOM变化\n    if (this.config.auto) {\n      this.startObserver();\n    }\n\n    return this;\n  }\n\n  // 开始观察DOM变化\n  startObserver() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n\n    this.observer = new MutationObserver((mutations) => {\n      let shouldTranslate = false;\n      for (const mutation of mutations) {\n        // 处理新增节点\n        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n          mutation.addedNodes.forEach(node => {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n              // 使用TreeWalker遍历所有元素节点\n              const treeWalker = document.createTreeWalker(\n                node,\n                NodeFilter.SHOW_ELEMENT,\n                this._createNodeFilter()\n              );\n\n              // 添加根节点\n              this.pendingElements.add(node);\n              shouldTranslate = true;\n\n              // 添加所有子元素节点\n              let currentNode;\n              while (currentNode = treeWalker.nextNode()) {\n                this.pendingElements.add(currentNode);\n              }\n            }\n          });\n        }\n\n        // 处理文本变化\n        if (mutation.type === 'characterData') {\n          const node = mutation.target.parentNode;\n          if (node && node.nodeType === Node.ELEMENT_NODE) {\n            // 检查所有父元素，如果有任何父元素被忽略且不在强制翻译列表中，则跳过\n            let shouldSkip = false;\n            let parent = node;\n\n            while (parent) {\n              if (this.ignoreSelectorString && parent.matches(this.ignoreSelectorString) &&\n                !(this.forceSelectorString && parent.matches(this.forceSelectorString))) {\n                shouldSkip = true;\n                break;\n              }\n              parent = parent.parentNode;\n              if (!parent || parent === document) break;\n            }\n\n            if (!shouldSkip) {\n              this.pendingElements.add(node);\n              shouldTranslate = true;\n            }\n          }\n        }\n      }\n\n      if (shouldTranslate) {\n        // 直接翻译\n        this._translatePending();\n      }\n    });\n\n    this.observer.observe(document.body, this.observerConfig);\n\n    return this;\n  }\n\n  // 停止观察DOM变化\n  stopObserver() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n\n    return this;\n  }\n\n  // 翻译待处理元素\n  async _translatePending() {\n    if (this.pendingElements.size === 0 || this.isTranslating) {\n      return;\n    }\n\n    this.isTranslating = true;\n\n    const elements = Array.from(this.pendingElements);\n    this.pendingElements.clear();\n\n    await this._translateElements(elements);\n\n    this.isTranslating = false;\n\n    // 检查是否有新的待处理元素\n    if (this.pendingElements.size > 0) {\n      this._translatePending();\n    }\n  }\n\n  // 翻译整个页面\n  async translatePage() {\n    if (this.isTranslating) {\n      return;\n    }\n\n    this.isTranslating = true;\n\n    // 临时停止观察器，避免翻译过程中触发更多的变化\n    const wasObserving = !!this.observer;\n    if (wasObserving) {\n      this.stopObserver();\n    }\n\n    // 执行beforeTranslate钩子\n    if (typeof this.config.hooks.before === 'function') {\n      await this.config.hooks.before();\n    }\n\n    try {\n      // 使用TreeWalker获取所有需要翻译的元素\n      const elements = [];\n      const rootElement = document.querySelector(this.config.root);\n\n      // 创建TreeWalker，只显示元素节点\n      const treeWalker = document.createTreeWalker(\n        rootElement,\n        NodeFilter.SHOW_ELEMENT,\n        this._createNodeFilter()\n      );\n\n      // 收集所有符合条件的元素\n      let node;\n      while (node = treeWalker.nextNode()) {\n        elements.push(node);\n      }\n\n      await this._translateElements(elements);\n    } catch (error) {\n      console.error('Tranzy: 页面翻译失败', error);\n    } finally {\n      // 执行afterTranslate钩子\n      if (typeof this.config.hooks.after === 'function') {\n        await this.config.hooks.after();\n      }\n\n      this.isTranslating = false;\n\n      // 如果之前在观察，重新启动观察器\n      if (wasObserving) {\n        this.startObserver();\n      }\n    }\n\n    return this;\n  }\n\n  // 翻译元素数组\n  async _translateElements(elements) {\n    // 过滤出需要翻译的元素并保存文本\n    const validElements = [];\n    const elementsText = [];\n    \n    for (const el of elements) {\n      const text = this._getElementText(el);\n      if (text) { // _getElementText 已经包含了对文本的验证\n        validElements.push(el);\n        elementsText.push(text);\n      }\n    }\n\n    if (validElements.length === 0) {\n      return;\n    }\n\n    // 批量处理元素\n    const batchSize = this.config.batch;\n    for (let i = 0; i < validElements.length; i += batchSize) {\n      const batchElements = validElements.slice(i, i + batchSize);\n      const batchTexts = elementsText.slice(i, i + batchSize);\n      await this._translateElementBatch(batchElements, batchTexts);\n    }\n  }\n\n  // 检查文本中是否包含术语并拆分\n  _splitByTerms(text) {\n    const toLangDict = this.config.manualDict[this.config.toLang];\n    if (!toLangDict) return [text];\n\n    // 按长度降序排序术语，优先匹配最长的术语\n    const terms = Object.keys(toLangDict).sort((a, b) => b.length - a.length);\n    \n    // 先检查是否有完全匹配的术语\n    for (const term of terms) {\n      const translation = toLangDict[term];\n      // 如果是独立匹配模式（默认为true）且文本完全等于术语\n      if ((translation.standalone !== false) && \n          (translation.case === false ? text.toLowerCase() === term.toLowerCase() : text === term)) {\n        return [text];\n      }\n    }\n\n    // 如果没有完全匹配，且文本中没有包含任何术语，直接返回原文本\n    let containsAnyTerm = false;\n    for (const term of terms) {\n      const translation = toLangDict[term];\n      if (translation.case === false ? \n          text.toLowerCase().includes(term.toLowerCase()) : \n          text.includes(term)) {\n        containsAnyTerm = true;\n        break;\n      }\n    }\n    \n    if (!containsAnyTerm) {\n      return [text];\n    }\n\n    // 拆分文本\n    const parts = [];\n    let currentText = text;\n    let lastIndex = 0;\n\n    while (currentText.length > 0) {\n      let foundTerm = false;\n      for (const term of terms) {\n        const translation = toLangDict[term];\n        // 跳过需要独立匹配的术语\n        if (translation.standalone !== false) {\n          continue;\n        }\n\n        // 使用正则表达式匹配术语，根据case配置决定是否忽略大小写\n        const flags = translation.case === false ? 'gi' : 'g';\n        const termRegex = new RegExp(`\\\\b${term}\\\\b`, flags);\n        const match = termRegex.exec(currentText);\n        \n        if (match) {\n          const index = match.index;\n          // 如果术语前面有文本，添加为一部分\n          if (index > 0) {\n            parts.push(currentText.substring(0, index));\n          }\n          // 添加术语\n          parts.push(term);\n          // 更新剩余文本\n          currentText = currentText.substring(index + term.length);\n          foundTerm = true;\n          break;\n        }\n      }\n      // 如果没有找到术语，将剩余文本作为一部分\n      if (!foundTerm) {\n        parts.push(currentText);\n        break;\n      }\n    }\n\n    return parts;\n  }\n\n  // 批量翻译元素\n  async _translateElementBatch(elements, textsArray) {\n    // 收集需要翻译的文本\n    const elementsWithText = [];\n    let textsToTranslate = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      const text = textsArray[i];\n      \n      // 执行beforeElementTranslate钩子\n      if (typeof this.config.hooks.beforeElement === 'function') {\n        const shouldContinue = await this.config.hooks.beforeElement(element);\n        if (shouldContinue === false) {\n          continue;\n        }\n      }\n\n      // text已经通过_getElementText过滤，无需额外检查\n      elementsWithText.push(element);\n      textsToTranslate.push(text);\n      // 添加正在翻译的class\n      element.classList.add(this.config.pendingClass);\n    }\n\n    if (textsToTranslate.length === 0) {\n      return;\n    }\n\n    // 创建翻译结果映射表\n    const translationMap = {};\n    const nodeTextMap = new Map(); // 存储元素到其直接文本节点的映射\n\n    // 预处理每个元素，收集直接文本节点\n    for (let i = 0; i < elementsWithText.length; i++) {\n      const element = elementsWithText[i];\n      \n      // 如果元素有子元素，需要单独处理每个文本节点\n      if (element.childElementCount > 0) {\n        // 收集元素的直接文本节点\n        const textNodes = [];\n        const treeWalker = document.createTreeWalker(\n          element,\n          NodeFilter.SHOW_TEXT,\n          {\n            acceptNode: function(node) {\n              if (node.parentNode !== element) {\n                return NodeFilter.FILTER_SKIP;\n              }\n              return NodeFilter.FILTER_ACCEPT;\n            }\n          }\n        );\n        \n        let node;\n        while (node = treeWalker.nextNode()) {\n          const text = node.textContent;\n          const trimmed = text.trim();\n          if (trimmed) {\n            textNodes.push({\n              node,\n              text: trimmed,\n              leadingSpaces: text.match(/^\\s*/)[0],\n              trailingSpaces: text.match(/\\s*$/)[0]\n            });\n          }\n        }\n        \n        // 如果有多个文本节点，存储映射关系\n        if (textNodes.length > 1) {\n          nodeTextMap.set(element, textNodes);\n          \n          // 为每个文本节点单独添加翻译任务\n          textNodes.forEach(nodeInfo => {\n            textsToTranslate.push(nodeInfo.text);\n            elementsWithText.push({\n              isTextNode: true,\n              nodeInfo\n            });\n          });\n          \n          // 移除原始元素的翻译任务\n          textsToTranslate[i] = null; // 标记为跳过\n        }\n      }\n    }\n\n    // 移除被标记为跳过的元素和文本\n    const validElementTexts = elementsWithText.filter((_, i) => textsToTranslate[i] !== null);\n    const validTexts = textsToTranslate.filter(text => text !== null);\n\n    // 用术语替换处理每个文本\n    const termProcessedTexts = [];\n    const termMappings = new Map();\n    \n    for (const text of validTexts) {\n      if (!text) continue;\n      \n      // 检查文本中是否包含术语\n      const parts = this._splitByTerms(text);\n      \n      // 如果被拆分，需要单独处理每个部分\n      if (parts.length > 1) {\n        termMappings.set(text, parts);\n        parts.forEach(part => termProcessedTexts.push(part));\n      } else {\n        termProcessedTexts.push(text);\n      }\n    }\n    \n    // 去重以减少翻译请求\n    const uniqueTextsToTranslate = [...new Set(termProcessedTexts)];\n    \n    // 检查手动词典和缓存\n    const manualTranslations = {};\n    const textsToBeCached = [];\n    const textsToFetch = [];\n    \n    for (const text of uniqueTextsToTranslate) {\n      // 检查手动词典\n      const toLangDict = this.config.manualDict[this.config.toLang];\n      const translation = toLangDict && (\n        toLangDict[text] || \n        (toLangDict[text.toLowerCase()]?.case === false ? toLangDict[text.toLowerCase()] : null)\n      );\n      \n      if (translation) {\n        manualTranslations[text] = translation.to;\n      } else {\n        // 检查缓存\n        const cachedTranslation = await this.cache.get(text, this.config.toLang, this.config.fromLang);\n        if (cachedTranslation) {\n          manualTranslations[text] = cachedTranslation;\n        } else {\n          textsToBeCached.push(text);\n          textsToFetch.push(text);\n        }\n      }\n    }\n    \n    // 翻译未缓存的文本\n    if (textsToFetch.length > 0) {\n      try {\n        const apiResults = await this.translator.translate(textsToFetch, this.config.toLang);\n        \n        // 更新缓存\n        await this.cache.setBatch(textsToFetch, apiResults, this.config.toLang, this.config.fromLang);\n        \n        // 合并翻译结果\n        textsToFetch.forEach((text, index) => {\n          manualTranslations[text] = apiResults[index];\n        });\n      } catch (error) {\n        console.error('Tranzy: 批量翻译失败', error);\n        textsToFetch.forEach(text => {\n          manualTranslations[text] = text; // 错误时保持原文\n        });\n      }\n    }\n    \n    // 构建最终翻译映射\n    const finalTranslations = new Map();\n    \n    // 首先处理被术语拆分的文本\n    for (const [originalText, parts] of termMappings.entries()) {\n      const translatedParts = parts.map(part => manualTranslations[part] || part);\n      finalTranslations.set(originalText, translatedParts.join(''));\n    }\n    \n    // 然后处理未被拆分的文本\n    for (const text of validTexts) {\n      if (!text || termMappings.has(text)) continue;\n      finalTranslations.set(text, manualTranslations[text] || text);\n    }\n    \n    // 应用翻译结果\n    validElementTexts.forEach((element, index) => {\n      const originalText = validTexts[index];\n      if (!originalText) return;\n      \n      const translatedText = finalTranslations.get(originalText);\n      if (!translatedText) return;\n      \n      // 处理文本节点\n      if (element.isTextNode) {\n        const { node, leadingSpaces, trailingSpaces } = element.nodeInfo;\n        node.textContent = leadingSpaces + translatedText + trailingSpaces;\n        \n        // 检查父元素是否已经处理完所有子节点\n        const parentElement = node.parentNode;\n        if (parentElement) {\n          // 标记父元素已翻译\n          parentElement.classList.remove(this.config.pendingClass);\n          parentElement.classList.add(this.config.doneClass);\n          \n          // 调用钩子\n          if (typeof this.config.hooks.afterElement === 'function') {\n            this.config.hooks.afterElement(parentElement, originalText, translatedText);\n          }\n        }\n      } else {\n        // 处理常规元素\n        element.classList.remove(this.config.pendingClass);\n        \n        // 如果是简单元素(没有被分解为单独节点)，直接应用翻译\n        if (!nodeTextMap.has(element)) {\n          this._applyTranslation(element, originalText, translatedText);\n        } else {\n          // 已经单独处理了各个文本节点，只需标记为已翻译\n          element.classList.add(this.config.doneClass);\n        }\n        \n        // 调用钩子\n        if (typeof this.config.hooks.afterElement === 'function') {\n          this.config.hooks.afterElement(element, originalText, translatedText);\n        }\n      }\n    });\n  }\n\n  // 获取元素文本内容\n  _getElementText(element) {\n    // 使用TreeWalker遍历元素的所有文本节点\n    let textContent = '';\n    const treeWalker = document.createTreeWalker(\n      element,\n      NodeFilter.SHOW_TEXT,\n      {\n        acceptNode: function (node) {\n          // 只获取直接的文本节点，跳过深层元素内的文本\n          if (node.parentNode !== element) {\n            return NodeFilter.FILTER_SKIP;\n          }\n          return NodeFilter.FILTER_ACCEPT;\n        }\n      }\n    );\n\n    let node;\n    while (node = treeWalker.nextNode()) {\n      const text = node.textContent.trim();\n      if (text) {\n        textContent += text + ' ';\n      }\n    }\n\n    textContent = textContent.trim();\n    \n    // 如果是空文本，直接返回null\n    if (!textContent || /^\\s*$/.test(textContent)) {\n      return null;\n    }\n    \n    // 过滤掉只包含数字、空格、回车、特殊字符的文本\n    // 但保留包含中文、英文、数字的文本\n    if (/^[\\s\\d\\p{P}\\p{S}]+$/u.test(textContent) && !/[\\p{L}\\u4e00-\\u9fa5]/.test(textContent)) {\n      return null;\n    }\n    \n    return textContent;\n  }\n\n  // 应用翻译\n  _applyTranslation(element, originalText, translatedText) {\n    if (!translatedText || originalText === translatedText) {\n      return;\n    }\n    \n    // 标记已翻译\n    element.classList.add(this.config.doneClass);\n    \n    // 如果元素有子元素，只替换直接的文本节点\n    if (element.childElementCount > 0) {\n      // 1. 收集所有直接文本节点信息\n      const textNodes = [];\n      const treeWalker = document.createTreeWalker(\n        element,\n        NodeFilter.SHOW_TEXT,\n        {\n          acceptNode: function(node) {\n            if (node.parentNode !== element) {\n              return NodeFilter.FILTER_SKIP;\n            }\n            return NodeFilter.FILTER_ACCEPT;\n          }\n        }\n      );\n      \n      let node;\n      while (node = treeWalker.nextNode()) {\n        const text = node.textContent;\n        const trimmed = text.trim();\n        if (trimmed) {\n          textNodes.push({\n            node,\n            text: trimmed,\n            leadingSpaces: text.match(/^\\s*/)[0],\n            trailingSpaces: text.match(/\\s*$/)[0]\n          });\n        }\n      }\n      \n      // 如果没有文本节点或只有一个文本节点，简单处理\n      if (textNodes.length === 0) {\n        return;\n      } else if (textNodes.length === 1) {\n        const { node, leadingSpaces, trailingSpaces } = textNodes[0];\n        node.textContent = leadingSpaces + translatedText + trailingSpaces;\n        return;\n      }\n      \n      // 注意：多文本节点的情况已在_translateElementBatch中处理\n      // 这里作为备用方案，使用简单的按比例分配\n      const totalTextLength = textNodes.reduce((sum, item) => sum + item.text.length, 0);\n      let usedTranslationLength = 0;\n      \n      textNodes.forEach((item, index) => {\n        const { node, text, leadingSpaces, trailingSpaces } = item;\n        let nodeTranslation;\n        \n        if (index === textNodes.length - 1) {\n          // 最后一个节点使用剩余的所有翻译文本\n          nodeTranslation = translatedText.substring(usedTranslationLength);\n        } else {\n          // 计算当前节点文本在原始完整文本中的占比\n          const ratio = text.length / totalTextLength;\n          // 根据比例计算应该分配的翻译文本长度\n          const translationLength = Math.round(translatedText.length * ratio);\n          \n          // 从当前位置提取对应长度的翻译文本\n          nodeTranslation = translatedText.substring(\n            usedTranslationLength, \n            usedTranslationLength + translationLength\n          );\n          \n          // 更新已使用的翻译文本长度\n          usedTranslationLength += translationLength;\n        }\n        \n        // 应用翻译结果到文本节点，保留原始空格\n        node.textContent = leadingSpaces + nodeTranslation + trailingSpaces;\n      });\n    } else {\n      // 如果没有子元素，保留原始文本中的空格\n      const leadingSpaces = element.textContent.match(/^\\s*/)[0];\n      const trailingSpaces = element.textContent.match(/\\s*$/)[0];\n      element.textContent = leadingSpaces + translatedText + trailingSpaces;\n    }\n  }\n\n  // 销毁实例，释放资源\n  destroy() {\n    // 停止DOM观察器\n    this.stopObserver();\n    \n    // 清空待处理元素\n    this.pendingElements.clear();\n    \n    // 关闭数据库连接\n    if (this.cache && this.cache.db) {\n      this.cache.db.close();\n      this.cache.db = null;\n    }\n    \n    // 重置状态\n    this.isTranslating = false;\n    \n    return this;\n  }\n}\n\nexport default Tranzy; "],"names":["DEFAULT_IGNORE_SELECTORS","DEFAULT_CONFIG","toLang","navigator","language","fromLang","root","ignore","force","doneClass","pendingClass","auto","batch","translator","manualDict","hooks","before","after","beforeElement","afterElement","mergeDeep","objects","reduce","prev","obj","Object","keys","forEach","key","pVal","oVal","Array","isArray","from","Set","isObject","item","TranslationCache","constructor","this","dbName","storeName","db","initPromise","_initDatabase","_generateHash","str","hash","i","length","charCodeAt","toString","Promise","resolve","reject","request","indexedDB","open","onupgradeneeded","event","target","result","objectStoreNames","contains","createObjectStore","keyPath","onsuccess","onerror","error","get","text","id","transaction","objectStore","value","set","translation","put","getBatch","texts","results","fill","remainingIndices","all","map","async","index","cachedTranslation","push","setBatch","translations","MicrosoftTranslator","tokenExpireMinutes","_loadTokenFromSession","tokenData","sessionStorage","getItem","token","timestamp","JSON","parse","now","Date","authToken","tokenTimestamp","_clearTokenFromSession","_saveTokenToSession","setItem","stringify","removeItem","getAuthToken","response","fetch","method","headers","ok","Error","status","statusText","translate","filteredTexts","filter","trim","url","data","Text","Authorization","body","json","config","lang","langDict","term","to","standalone","case","cache","isTranslating","pendingElements","observer","observerConfig","childList","subtree","forceSelectorString","ignoreSelectorString","_createNodeFilter","acceptNode","node","classList","NodeFilter","FILTER_SKIP","matches","FILTER_ACCEPT","parent","parentNode","document","children","querySelector","FILTER_REJECT","bind","join","translatePage","startObserver","disconnect","MutationObserver","mutations","shouldTranslate","mutation","type","addedNodes","nodeType","Node","ELEMENT_NODE","treeWalker","createTreeWalker","SHOW_ELEMENT","currentNode","add","nextNode","shouldSkip","_translatePending","observe","stopObserver","size","elements","clear","_translateElements","wasObserving","rootElement","validElements","elementsText","el","_getElementText","batchSize","batchElements","slice","batchTexts","_translateElementBatch","_splitByTerms","toLangDict","terms","sort","a","b","toLowerCase","containsAnyTerm","includes","parts","currentText","foundTerm","flags","match","RegExp","exec","substring","textsArray","elementsWithText","textsToTranslate","element","nodeTextMap","Map","childElementCount","textNodes","SHOW_TEXT","textContent","trimmed","leadingSpaces","trailingSpaces","nodeInfo","isTextNode","validElementTexts","_","validTexts","termProcessedTexts","termMappings","part","uniqueTextsToTranslate","manualTranslations","textsToFetch","apiResults","finalTranslations","originalText","entries","translatedParts","has","translatedText","parentElement","remove","_applyTranslation","test","totalTextLength","sum","usedTranslationLength","nodeTranslation","ratio","translationLength","Math","round","destroy","close"],"mappings":"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"}