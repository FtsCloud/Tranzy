{"version":3,"file":"tranzy.es.js","sources":["../src/tranzy.js"],"sourcesContent":["/**\n * Tranzy - 网页自动翻译插件\n *\n * 主要功能：\n * 1. 自动检测DOM变化并翻译新增内容\n * 2. 支持批量翻译和缓存机制\n * 3. 提供灵活的配置选项和钩子函数\n * 4. 支持手动翻译词典和术语处理\n * 5. 内置微软翻译API实现\n *\n * 使用方式：\n * 1. 直接使用翻译功能：\n *    import { translateText } from 'tranzy';\n *    const result = await translateText(['Hello'], 'zh', 'en');\n *\n * 2. 使用页面翻译功能：\n *    import Tranzy from 'tranzy';\n *    const tranzy = new Tranzy({\n *      toLang: 'zh',\n *      fromLang: 'en'\n *    });\n *    await tranzy.translatePage();\n *\n * @author Fts Cloud <ftsuperb@vip.qq.com>\n * @license MIT\n * @repository https://github.com/FtsCloud/Tranzy\n * @copyright Copyright (c) 2023-present Fts Cloud\n */\n\n// 默认忽略的选择器列表，这些元素及其内容不会被翻译\nconst DEFAULT_IGNORE_SELECTORS = [\n  'style',            // 样式标签\n  'script',           // 脚本标签\n  'noscript',         // 无脚本标签\n  'kbd',              // 键盘输入标签\n  'code',             // 代码标签\n  'pre',              // 预格式化文本标签\n  'input',            // 输入框\n  'textarea',         // 文本域\n  '[contenteditable=\"true\"]', // 可编辑元素\n  '.tranzy-ignore'    // 自定义忽略类\n];\n\n// 默认配置选项\nconst DEFAULT_CONFIG = {\n  toLang: navigator.language || '',    // 目标语言，默认从浏览器语言设置获取\n  fromLang: '',                        // 源语言，如：'en'\n  ignore: [],                          // 自定义忽略选择器列表\n  force: [],                           // 强制翻译选择器列表\n  doneClass: 'tranzy-done',            // 已翻译元素的标记类\n  pendingClass: 'tranzy-pending',      // 正在翻译中的元素标记类\n  translateFn: translateText,          // 默认使用translateText函数\n  manualDict: {},                      // 手动翻译词典\n  beforeTranslate: null,               // 翻译开始前的钩子\n  afterTranslate: null,                // 翻译结束后的钩子\n};\n\n/**\n * 翻译缓存管理器\n * 使用IndexedDB存储翻译结果，提高性能并减少API调用\n */\nclass TranslationCache {\n  constructor() {\n    this.dbName = 'tranzy-cache';      // 数据库名称\n    this.storeName = 'translations';    // 存储对象名称\n    this.db = null;                     // 数据库实例\n    this.initPromise = this._initDatabase(); // 初始化Promise\n  }\n\n  /**\n   * 生成字符串哈希值\n   * 使用FNV-1a哈希算法，生成base36编码的短哈希值\n   * @param {string} str - 需要哈希的字符串\n   * @returns {string} - base36编码的哈希值\n   */\n  _generateHash(str) {\n    let hash = 2166136261;\n    for (let i = 0; i < str.length; i++) {\n      hash ^= str.charCodeAt(i);\n      hash *= 16777619;\n    }\n    return hash.toString(36);\n  }\n\n  /**\n   * 初始化IndexedDB数据库\n   * 创建数据库和存储对象，处理版本升级\n   * @returns {Promise} - 初始化完成的Promise\n   */\n  async _initDatabase() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, 1);\n\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          db.createObjectStore(this.storeName, {keyPath: 'id'});\n        }\n      };\n\n      request.onsuccess = (event) => {\n        this.db = event.target.result;\n        resolve();\n      };\n\n      request.onerror = (event) => {\n        console.error('Tranzy: Failed to initialize cache database / 初始化缓存数据库失败', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  }\n\n  /**\n   * 获取缓存的翻译结果\n   * @param {string} text - 原文\n   * @param {string} toLang - 目标语言\n   * @param {string} [fromLang=''] - 源语言\n   * @returns {Promise<string|null>} - 缓存的翻译结果或null\n   */\n  async get(text, toLang, fromLang = '') {\n    await this.initPromise;\n    const id = this._generateHash(`${text}|${toLang}|${fromLang}`);\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve(null);\n        return;\n      }\n\n      const transaction = this.db.transaction(this.storeName, 'readonly');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.get(id);\n\n      request.onsuccess = (event) => {\n        resolve(event.target.result?.value || null);\n      };\n\n      request.onerror = () => {\n        resolve(null);\n      };\n    });\n  }\n\n  /**\n   * 设置翻译结果到缓存\n   * @param {string} text - 原文\n   * @param {string} translation - 翻译结果\n   * @param {string} toLang - 目标语言\n   * @param {string} [fromLang=''] - 源语言\n   * @returns {Promise<void>}\n   */\n  async set(text, translation, toLang, fromLang = '') {\n    await this.initPromise;\n    const id = this._generateHash(`${text}|${toLang}|${fromLang}`);\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve();\n        return;\n      }\n\n      const transaction = this.db.transaction(this.storeName, 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.put({\n        id,\n        value: translation\n      });\n\n      request.onsuccess = () => {\n        resolve();\n      };\n\n      request.onerror = () => {\n        resolve();\n      };\n    });\n  }\n\n  /**\n   * 批量设置翻译结果到缓存\n   * @param {string[]} texts - 原文数组\n   * @param {string[]} translations - 翻译结果数组\n   * @param {string} toLang - 目标语言\n   * @param {string} [fromLang=''] - 源语言\n   * @returns {Promise<void>}\n   */\n  async setBatch(texts, translations, toLang, fromLang = '') {\n    await this.initPromise;\n    await Promise.all(texts.map((text, index) => {\n      return this.set(text, translations[index], toLang, fromLang);\n    }));\n  }\n}\n\n/**\n * 从sessionStorage加载认证token\n * @returns {{token: string|null, timestamp: number}} - token和获取时间戳\n */\nfunction loadTokenFromSession() {\n  try {\n    const tokenData = sessionStorage.getItem('tranzy_auth_token');\n    if (tokenData) {\n      const {\n        token,\n        timestamp\n      } = JSON.parse(tokenData);\n      const now = Date.now();\n      // 如果token未过期，则使用缓存的token\n      if (token && (now - timestamp) < 10 * 60 * 1000) {\n        return {\n          token,\n          timestamp\n        };\n      }\n      // token已过期，清除缓存\n      clearTokenFromSession();\n    }\n  } catch (error) {\n    console.error('Tranzy: Failed to load token from session / 从session加载token失败', error);\n    clearTokenFromSession();\n  }\n  return {\n    token: null,\n    timestamp: 0\n  };\n}\n\n/**\n * 保存认证token到sessionStorage\n * @param {string} token - 认证token\n * @param {number} timestamp - 获取时间戳\n */\nfunction saveTokenToSession(token, timestamp) {\n  try {\n    sessionStorage.setItem('tranzy_auth_token', JSON.stringify({\n      token,\n      timestamp\n    }));\n  } catch (error) {\n    console.error('Tranzy: Failed to save token to session / 保存token到session失败', error);\n  }\n}\n\n/**\n * 清除sessionStorage中的认证token\n */\nfunction clearTokenFromSession() {\n  try {\n    sessionStorage.removeItem('tranzy_auth_token');\n  } catch (error) {\n    console.error('Tranzy: Failed to clear token from session / 清除session中的token失败', error);\n  }\n}\n\n/**\n * 获取微软翻译API的认证token\n * 优先使用缓存的token，如果过期则重新获取\n * @returns {Promise<string>} - 认证token\n */\nasync function getAuthToken() {\n  const now = Date.now();\n  const {\n    token,\n    timestamp\n  } = loadTokenFromSession();\n\n  // 如果token获取时间小于10分钟，则直接返回\n  if (token && (now - timestamp) < 10 * 60 * 1000) {\n    return token;\n  }\n\n  try {\n    const response = await fetch('https://edge.microsoft.com/translate/auth', {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      }\n    });\n\n    if (!response.ok) {\n      console.error(`Tranzy: Failed to get Microsoft Translator authorization / 获取微软翻译授权失败: ${response.status} ${response.statusText}`);\n      return null;\n    }\n\n    const newToken = await response.text();\n    saveTokenToSession(newToken, now);\n\n    return newToken;\n  } catch (error) {\n    console.error('Tranzy: Failed to get Microsoft Translator authorization / 获取微软翻译授权失败', error);\n    clearTokenFromSession();\n    throw error;\n  }\n}\n\n/**\n * 调用微软翻译API进行翻译\n * @param {string[]} texts - 需要翻译的文本数组\n * @param {string} toLang - 目标语言代码\n * @param {string} [fromLang=''] - 源语言代码\n * @returns {Promise<string[]>} - 翻译结果数组\n */\nexport async function translateText(texts, toLang = navigator.language, fromLang = '') {\n  try {\n    // 过滤掉空文本和null值\n    const filteredTexts = texts.filter(text => text?.trim());\n\n    // 如果没有有效文本需要翻译，直接返回空数组\n    if (filteredTexts.length === 0) {\n      return [];\n    }\n\n    // 获取认证令牌\n    const token = await getAuthToken();\n\n    // 构建URL，只在设置了fromLang时添加from参数\n    const url = `https://api.cognitive.microsofttranslator.com/translate?${fromLang ? `from=${fromLang}&` : ''}to=${toLang}&api-version=3.0`\n\n    // 构建请求数据\n    const data = filteredTexts.map(text => ({Text: text}));\n\n    // 发送请求\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`\n      },\n      body: JSON.stringify(data)\n    });\n\n    if (!response.ok) {\n      console.error(`Tranzy: Translation request failed / 翻译请求失败: ${response.status} ${response.statusText}`);\n      return texts; // 返回原文\n    }\n\n    // 处理响应\n    const result = await response.json();\n    return result.map(item => item.translations[0].text);\n  } catch (error) {\n    console.error('Tranzy: Translation request failed / 翻译请求失败', error);\n    throw error;\n  }\n}\n\n/**\n * 检测文本的语言\n * @param {string|string[]} texts - 需要检测语言的文本或文本数组\n * @returns {Promise<Array<{language: string, score: number, isTranslationSupported: boolean, isTransliterationSupported: boolean}>>} - 语言检测结果数组\n */\nexport async function detectLang(texts) {\n  try {\n    // 确保texts是数组\n    const textArray = Array.isArray(texts) ? texts : [texts];\n\n    // 过滤掉空文本和null值\n    const filteredTexts = textArray.filter(text => text?.trim());\n\n    // 如果没有有效文本需要检测，直接返回空数组\n    if (filteredTexts.length === 0) {\n      return [];\n    }\n\n    // 获取认证令牌\n    const token = await getAuthToken();\n\n    // 构建请求数据\n    const data = filteredTexts.map(text => ({Text: text}));\n\n    // 发送请求\n    const response = await fetch('https://api.cognitive.microsofttranslator.com/detect?api-version=3.0', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`\n      },\n      body: JSON.stringify(data)\n    });\n\n    if (!response.ok) {\n      console.error(`Tranzy: Language detection request failed / 语言检测请求失败: ${response.status} ${response.statusText}`);\n      return []; // 返回空数组\n    }\n\n    // 处理响应\n    return await response.json();\n  } catch (error) {\n    console.error('Tranzy: Language detection failed / 语言检测失败', error);\n    throw error;\n  }\n}\n\n/**\n * 获取支持的语种列表\n * @param {string} [displayLang=''] - 用于显示语言名称的BCP 47语言代码，例如：'zh-CN'表示用简体中文显示语言名称\n * @returns {Promise<Object>} - 支持的语种列表，格式为 { languageCode: { name: string, nativeName: string, dir: string } }\n * 注意：所有语言代码均遵循BCP 47规范，例如：'zh-CN'、'en'、'ja'等\n */\nexport async function getSupportedLangs(displayLang = '') {\n  try {\n    // 构建请求头\n    const headers = {\n      'Content-Type': 'application/json'\n    };\n\n    // 如果指定了显示语言，添加到请求头\n    if (displayLang) {\n      headers['Accept-Language'] = displayLang;\n    }\n\n    // 发送请求\n    const response = await fetch('https://api.cognitive.microsofttranslator.com/languages?api-version=3.0', {\n      method: 'GET',\n      headers\n    });\n\n    if (!response.ok) {\n      console.error(`Tranzy: Failed to get supported languages / 获取支持语种列表失败: ${response.status} ${response.statusText}`);\n      return {}; // 返回空对象\n    }\n\n    // 处理响应，只返回translation部分\n    const result = await response.json();\n    return result.translation;\n  } catch (error) {\n    console.error('Tranzy: Failed to get supported languages / 获取支持语种列表失败', error);\n    throw error;\n  }\n}\n\n/**\n * 获取浏览器语言对应的支持语言代码\n * @returns {Promise<string>} - 支持的语言代码，例如：'zh-Hans'、'en'等\n * 注意：返回的语言代码遵循BCP 47规范\n */\nexport async function getBrowserLang() {\n  try {\n    // 获取浏览器语言\n    const browserLang = navigator.language;\n\n    // 获取认证令牌\n    const token = await getAuthToken();\n\n    // 发送请求，翻译空字符串\n    const response = await fetch(`https://api.cognitive.microsofttranslator.com/translate?to=${browserLang}&api-version=3.0`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`\n      },\n      body: JSON.stringify([{Text: ''}])\n    });\n\n    if (!response.ok) {\n      console.error(`Tranzy: Failed to get browser language / 获取浏览器语言失败: ${response.status} ${response.statusText}`);\n      return navigator.language || 'en'; // 返回浏览器语言或默认英语\n    }\n\n    // 处理响应，获取支持的语言代码\n    const result = await response.json();\n    return result[0].translations[0].to;\n  } catch (error) {\n    console.error('Tranzy: Failed to get browser language / 获取浏览器语言失败', error);\n    throw error;\n  }\n}\n\n/**\n * Tranzy核心类\n * 提供页面翻译和DOM变化监听功能\n */\nexport class Translator {\n  /**\n   * 创建Translator实例\n   * @param {Object} config - 配置选项\n   * @param {string} config.toLang - 目标语言代码\n   * @param {string} [config.fromLang=''] - 源语言代码\n   * @param {string[]} [config.ignore=[]] - 忽略的选择器列表\n   * @param {string[]} [config.force=[]] - 强制翻译的选择器列表\n   * @param {string} [config.doneClass='tranzy-done'] - 已翻译元素的标记类\n   * @param {string} [config.pendingClass='tranzy-pending'] - 正在翻译中的元素标记类\n   * @param {Function} [config.translateFn=null] - 自定义翻译函数\n   * @param {Object} [config.manualDict={}] - 手动翻译词典\n   * @param {Function} [config.beforeTranslate=null] - 翻译开始前的钩子\n   * @param {Function} [config.afterTranslate=null] - 翻译结束后的钩子\n   */\n  constructor(config = {}) {\n    this.config = {...DEFAULT_CONFIG, ...config};\n\n    // 合并 all 配置到当前语言的配置中，当前语言的优先级更高\n    this.config.manualDict[this.config.toLang] = {\n      ...this.config.manualDict.all || {}, ...this.config.manualDict[this.config.toLang] || {}\n    };\n\n    // 标准化manualDict配置\n    const langDict = this.config.manualDict[this.config.toLang];\n    for (const term of Object.keys(langDict)) {\n      // 如果翻译值是字符串，转换为标准格式\n      if (typeof langDict[term] === 'string') {\n        langDict[term] = {\n          to: langDict[term],\n          standalone: true,\n          case: true\n        };\n      }\n    }\n\n    this.observer = null;\n    this.translationCache = new TranslationCache();\n\n    // 合并并去重忽略选择器\n    this.config.ignore = [\n      ...new Set([\n        ...DEFAULT_IGNORE_SELECTORS,\n        ...(this.config.ignore || [])\n      ])\n    ];\n\n    // 确保强制翻译选择器是数组\n    this.config.force = this.config.force || [];\n\n    // 将数组选择器合并为字符串选择器，提高性能\n    this.forceSelectorString = this.config.force.length ? this.config.force.join(',') : '';\n    this.ignoreSelectorString = this.config.ignore.length ? this.config.ignore.join(',') : '';\n\n    // 初始化状态\n    this.isTranslating = false;         // 是否正在翻译\n    this.pendingElements = new Set();   // 待翻译元素集合\n    this.observerConfig = {             // 观察器配置\n      childList: true,                  // 观察子节点变化\n      subtree: true,                    // 观察后代节点变化\n      characterData: true               // 观察文本内容变化\n    };\n  }\n\n  /**\n   * 创建节点过滤器\n   * 用于TreeWalker，决定哪些节点需要被翻译\n   * @returns {Object} - 节点过滤器对象\n   */\n  _createNodeFilter() {\n    return {\n      acceptNode: function (node) {\n        // 跳过已翻译的元素，但允许检查其子元素\n        if (node.classList.contains(this.config.doneClass)) {\n          return NodeFilter.FILTER_SKIP;\n        }\n\n        // 优先级1：检查当前节点是否匹配force选择器\n        if (this.forceSelectorString && node.matches(this.forceSelectorString)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        // 优先级2：检查父节点是否匹配force选择器\n        if (this.forceSelectorString) {\n          let parent = node.parentNode;\n          while (parent && parent !== document) {\n            if (parent.matches(this.forceSelectorString)) {\n              return NodeFilter.FILTER_ACCEPT;\n            }\n            parent = parent.parentNode;\n          }\n        }\n\n        // 优先级3：检查子节点是否匹配force选择器\n        let hasForceChild = false;\n        if (this.forceSelectorString && node.children.length > 0) {\n          hasForceChild = node.querySelector(this.forceSelectorString);\n        }\n\n        // 优先级4：检查当前节点是否匹配ignore选择器\n        if (this.ignoreSelectorString && node.matches(this.ignoreSelectorString)) {\n          return hasForceChild ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;\n        }\n\n        // 优先级5：检查父节点是否匹配ignore选择器\n        if (this.ignoreSelectorString) {\n          let parent = node.parentNode;\n          while (parent && parent !== document) {\n            if (parent.matches(this.ignoreSelectorString)) {\n              return hasForceChild ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;\n            }\n            parent = parent.parentNode;\n          }\n        }\n\n        // 默认接受：如果以上所有条件都不满足，接受节点进行翻译\n        return NodeFilter.FILTER_ACCEPT;\n      }.bind(this)\n    };\n  }\n\n  /**\n   * 开始观察DOM变化\n   * @param {string} [root='body'] - 观察的根元素选择器\n   * @returns {Translator} - 当前实例，支持链式调用\n   */\n  startObserver(root = 'body') {\n    // 如果源语言和目标语言相同，跳过翻译过程\n    if (this.config.fromLang === this.config.toLang) {\n      return this;\n    }\n\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n\n    this.observer = new MutationObserver((mutations) => {\n      let shouldTranslate = false;\n      for (const mutation of mutations) {\n        // 处理新增节点\n        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n          for (const node of mutation.addedNodes) {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n              // 使用TreeWalker遍历所有元素节点\n              const treeWalker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, this._createNodeFilter());\n\n              // 收集所有符合条件的元素\n              let currentNode = treeWalker.nextNode();\n              while (currentNode) {\n                this.pendingElements.add(currentNode);\n                shouldTranslate = true;\n                currentNode = treeWalker.nextNode();\n              }\n            }\n          }\n        }\n\n        // 处理文本变化\n        if (mutation.type === 'characterData') {\n          const node = mutation.target.parentNode;\n          if (node && node.nodeType === Node.ELEMENT_NODE) {\n            // 检查节点是否正在翻译中\n            if (node.classList.contains(this.config.pendingClass)) {\n              continue;\n            }\n\n            // 检查所有父元素，如果有任何父元素被忽略且不在强制翻译列表中，则跳过\n            let shouldSkip = false;\n            let parent = node;\n\n            while (parent) {\n              if (this.ignoreSelectorString && parent.matches(this.ignoreSelectorString) && !(this.forceSelectorString && parent.matches(this.forceSelectorString))) {\n                shouldSkip = true;\n                break;\n              }\n              parent = parent.parentNode;\n              if (!parent || parent === document) {\n                break;\n              }\n            }\n\n            if (!shouldSkip) {\n              this.pendingElements.add(node);\n              shouldTranslate = true;\n            }\n          }\n        }\n      }\n\n      if (shouldTranslate) {\n        // 直接翻译\n        this._translatePending();\n      }\n    });\n\n    this.observer.observe(document.querySelector(root), this.observerConfig);\n\n    return this;\n  }\n\n  /**\n   * 停止观察DOM变化\n   * @returns {Translator} - 当前实例，支持链式调用\n   */\n  stopObserver() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n\n    return this;\n  }\n\n  /**\n   * 翻译待处理元素\n   * @param {boolean} [again=false] - 是否是重复翻译\n   * @private\n   */\n  async _translatePending(again = false) {\n    if (this.pendingElements.size === 0 || this.isTranslating) {\n      return;\n    }\n\n    if (!again && typeof this.config.beforeTranslate === 'function') {\n      this.config.beforeTranslate();\n    }\n\n    this.isTranslating = true;\n\n    const elements = Array.from(this.pendingElements);\n    this.pendingElements.clear();\n\n    await this._translateElements(elements);\n\n    this.isTranslating = false;\n\n    // 检查是否有新的待处理元素\n    if (this.pendingElements.size > 0) {\n      this._translatePending(true);\n    } else {\n      if (typeof this.config.afterTranslate === 'function') {\n        this.config.afterTranslate();\n      }\n    }\n  }\n\n  /**\n   * 翻译整个页面\n   * @param {string} [root='body'] - 翻译的根元素选择器\n   * @returns {Promise<Translator>} - 当前实例，支持链式调用\n   */\n  async translatePage(root = 'body') {\n    // 如果源语言和目标语言相同，跳过翻译过程\n    if (this.isTranslating || this.config.fromLang === this.config.toLang) {\n      return this;\n    }\n\n    this.isTranslating = true;\n\n    // 临时停止观察器，避免翻译过程中触发更多的变化\n    const wasObserving = !!this.observer;\n    if (wasObserving) {\n      this.stopObserver();\n    }\n\n    // 执行beforeTranslate钩子\n    if (typeof this.config.beforeTranslate === 'function') {\n      this.config.beforeTranslate();\n    }\n\n    try {\n      // 使用TreeWalker获取所有需要翻译的元素\n      const elements = [];\n      const rootElement = document.querySelector(root);\n\n      // 创建TreeWalker，只显示元素节点\n      const treeWalker = document.createTreeWalker(rootElement, NodeFilter.SHOW_ELEMENT, this._createNodeFilter());\n\n      // 收集所有符合条件的元素\n      let node = treeWalker.nextNode();\n      while (node) {\n        elements.push(node);\n        node = treeWalker.nextNode();\n      }\n\n      await this._translateElements(elements);\n    } catch (error) {\n      console.error('Tranzy: Page translation failed / 页面翻译失败', error);\n    } finally {\n      // 执行afterTranslate钩子\n      if (typeof this.config.afterTranslate === 'function') {\n        this.config.afterTranslate();\n      }\n\n      this.isTranslating = false;\n\n      // 如果之前在观察，重新启动观察器\n      if (wasObserving) {\n        this.startObserver(root);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * 翻译元素数组\n   * @param {Element[]} elements - 需要翻译的元素数组\n   * @private\n   */\n  async _translateElements(elements) {\n    // 过滤出需要翻译的元素并保存文本\n    const validElements = [];\n    const elementsText = [];\n\n    for (const el of elements) {\n      const text = this._getElementText(el);\n      if (text) {\n        validElements.push(el);\n        elementsText.push(text);\n      }\n    }\n\n    if (validElements.length === 0) {\n      return;\n    }\n\n    // 批量处理元素\n    for (let i = 0; i < validElements.length; i += 100) {\n      const batchElements = validElements.slice(i, i + 100);\n      const batchTexts = elementsText.slice(i, i + 100);\n      await this._translateElementBatch(batchElements, batchTexts);\n    }\n  }\n\n  /**\n   * 检查文本中是否包含术语并拆分\n   * @param {string} text - 需要检查的文本\n   * @returns {string[]} - 拆分后的文本数组\n   * @private\n   */\n  _splitByTerms(text) {\n    const toLangDict = this.config.manualDict[this.config.toLang];\n    if (!toLangDict) {\n      return [text];\n    }\n\n    // 按长度降序排序术语，优先匹配最长的术语\n    const terms = Object.keys(toLangDict).sort((a, b) => b.length - a.length);\n\n    // 先检查是否有完全匹配的术语\n    for (const term of terms) {\n      const translation = toLangDict[term];\n      // 如果是独立匹配模式（默认为true）且文本完全等于术语\n      if ((translation.standalone !== false) && (translation.case === false ? text.toLowerCase() === term.toLowerCase() : text === term)) {\n        return [text];\n      }\n    }\n\n    // 如果没有完全匹配，且文本中没有包含任何术语，直接返回原文本\n    let containsAnyTerm = false;\n    for (const term of terms) {\n      const translation = toLangDict[term];\n      if (translation.case === false ? text.toLowerCase().includes(term.toLowerCase()) : text.includes(term)) {\n        containsAnyTerm = true;\n        break;\n      }\n    }\n\n    if (!containsAnyTerm) {\n      return [text];\n    }\n\n    // 拆分文本\n    const parts = [];\n    let currentText = text;\n\n    while (currentText.length > 0) {\n      let foundTerm = false;\n      for (const term of terms) {\n        const translation = toLangDict[term];\n        // 跳过需要独立匹配的术语\n        if (translation.standalone !== false) {\n          continue;\n        }\n\n        // 使用正则表达式匹配术语，根据case配置决定是否忽略大小写\n        const flags = translation.case === false ? 'gi' : 'g';\n        const termRegex = new RegExp(`\\\\b${term}\\\\b`, flags);\n        const match = termRegex.exec(currentText);\n\n        if (match) {\n          const index = match.index;\n          // 如果术语前面有文本，添加为一部分\n          if (index > 0) {\n            parts.push(currentText.substring(0, index));\n          }\n          // 添加术语\n          parts.push(term);\n          // 更新剩余文本\n          currentText = currentText.substring(index + term.length);\n          foundTerm = true;\n          break;\n        }\n      }\n      // 如果没有找到术语，将剩余文本作为一部分\n      if (!foundTerm) {\n        parts.push(currentText);\n        break;\n      }\n    }\n\n    return parts;\n  }\n\n  /**\n   * 获取元素的直接文本节点\n   * @param {Element} element - 需要获取文本节点的元素\n   * @returns {Array<{node: Text, text: string, leadingSpaces: string, trailingSpaces: string}>} - 文本节点信息数组\n   * @private\n   */\n  _getDirectTextNodes(element) {\n    const textNodes = [];\n    const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, {\n      acceptNode: (node) => {\n        if (node.parentNode !== element) {\n          return NodeFilter.FILTER_SKIP;\n        }\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    });\n\n    let node = treeWalker.nextNode();\n    while (node) {\n      const text = node.textContent;\n      const trimmed = text.trim();\n      if (trimmed) {\n        textNodes.push({\n          node,\n          text: trimmed,\n          leadingSpaces: text.match(/^\\s*/)[0],\n          trailingSpaces: text.match(/\\s*$/)[0]\n        });\n      }\n      node = treeWalker.nextNode();\n    }\n\n    return textNodes;\n  }\n\n  /**\n   * 批量翻译元素\n   * @param {Element[]} elements - 需要翻译的元素数组\n   * @param {string[]} textsArray - 对应的文本数组\n   * @private\n   */\n  async _translateElementBatch(elements, textsArray) {\n    // 收集需要翻译的文本和对应的元素\n    const elementsWithText = [];\n    const textsToTranslate = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      const text = textsArray[i];\n\n      // 将元素和文本添加到待处理列表\n      elementsWithText.push(element);\n      textsToTranslate.push(text);\n      // 标记元素为正在翻译状态，防止重复处理\n      element.classList.add(this.config.pendingClass);\n    }\n\n    if (textsToTranslate.length === 0) {\n      return;\n    }\n\n    // 创建元素到其直接文本节点的映射表\n    const nodeTextMap = new Map();\n\n    // 预处理每个元素，收集其直接文本节点\n    for (let i = 0; i < elementsWithText.length; i++) {\n      const element = elementsWithText[i];\n\n      // 如果元素包含子元素，需要单独处理每个文本节点\n      if (element.childElementCount > 0) {\n        // 收集元素的直接文本节点（不包含子元素的文本节点）\n        const textNodes = this._getDirectTextNodes(element);\n\n        // 如果元素包含多个文本节点，需要特殊处理\n        if (textNodes.length > 1) {\n          // 存储元素到其文本节点的映射关系，用于后续处理\n          nodeTextMap.set(element, textNodes);\n\n          // 为每个文本节点创建独立的翻译任务\n          for (const nodeInfo of textNodes) {\n            textsToTranslate.push(nodeInfo.text);\n            elementsWithText.push({\n              isTextNode: true,\n              nodeInfo\n            });\n          }\n\n          // 标记原始元素的翻译任务为跳过，因为已经为每个文本节点创建了独立任务\n          textsToTranslate[i] = null;\n        }\n      }\n    }\n\n    // 过滤掉被标记为跳过的元素和文本\n    const validElementTexts = elementsWithText.filter((_, i) => textsToTranslate[i] !== null);\n    const validTexts = textsToTranslate.filter(text => text !== null);\n\n    // 用术语替换处理每个文本\n    const termProcessedTexts = [];\n    const termMappings = new Map();\n\n    for (const text of validTexts) {\n      if (!text) {\n        continue;\n      }\n\n      // 检查文本中是否包含术语\n      const parts = this._splitByTerms(text);\n\n      // 如果被拆分，需要单独处理每个部分\n      if (parts.length > 1) {\n        termMappings.set(text, parts);\n        for (const part of parts) {\n          termProcessedTexts.push(part)\n        }\n      } else {\n        termProcessedTexts.push(text);\n      }\n    }\n\n    // 去重以减少翻译请求\n    const uniqueTextsToTranslate = [...new Set(termProcessedTexts)];\n\n    // 检查手动词典和缓存\n    const manualTranslations = {};\n    const textsToFetch = [];\n\n    for (const text of uniqueTextsToTranslate) {\n      // 检查手动词典\n      const toLangDict = this.config.manualDict[this.config.toLang];\n      const translation = toLangDict && (toLangDict[text] || (toLangDict[text.toLowerCase()]?.case === false ? toLangDict[text.toLowerCase()] : null));\n\n      if (translation) {\n        manualTranslations[text] = translation.to;\n      } else {\n        // 检查缓存\n        const cachedTranslation = await this.translationCache.get(text, this.config.toLang, this.config.fromLang);\n        if (cachedTranslation) {\n          manualTranslations[text] = cachedTranslation;\n        } else {\n          textsToFetch.push(text);\n        }\n      }\n    }\n\n    // 翻译未缓存的文本\n    if (textsToFetch.length > 0) {\n      try {\n        const apiResults = await this.config.translateFn(textsToFetch, this.config.toLang, this.config.fromLang);\n\n        // 更新缓存\n        await this.translationCache.setBatch(textsToFetch, apiResults, this.config.toLang, this.config.fromLang);\n\n        // 合并翻译结果\n        textsToFetch.forEach((text, index) => {\n          manualTranslations[text] = apiResults[index];\n        });\n      } catch (error) {\n        console.error('Tranzy: Batch translation failed / 批量翻译失败', error);\n        for (const text of textsToFetch) {\n          manualTranslations[text] = text; // 错误时保持原文\n        }\n      }\n    }\n\n    // 构建最终翻译映射\n    const finalTranslations = new Map();\n\n    // 首先处理被术语拆分的文本\n    for (const [originalText, parts] of termMappings.entries()) {\n      const translatedParts = parts.map(part => manualTranslations[part] || part);\n      finalTranslations.set(originalText, translatedParts.join(''));\n    }\n\n    // 然后处理未被拆分的文本\n    for (const text of validTexts) {\n      if (!text || termMappings.has(text)) {\n        continue;\n      }\n      finalTranslations.set(text, manualTranslations[text] || text);\n    }\n\n    // 应用翻译结果\n    validElementTexts.forEach((element, index) => {\n      const originalText = validTexts[index];\n      if (!originalText) {\n        return;\n      }\n\n      const translatedText = finalTranslations.get(originalText);\n      if (!translatedText) {\n        return;\n      }\n\n      // 处理文本节点\n      if (element.isTextNode) {\n        const {\n          node,\n          leadingSpaces,\n          trailingSpaces\n        } = element.nodeInfo;\n        node.textContent = leadingSpaces + translatedText + trailingSpaces;\n\n        // 检查父元素是否已经处理完所有子节点\n        const parentElement = node.parentNode;\n        if (parentElement) {\n          // 等待下一个微任务，确保DOM更新完成\n          queueMicrotask(() => {\n            parentElement.classList.remove(this.config.pendingClass);\n            parentElement.classList.add(this.config.doneClass);\n          });\n        }\n      } else {\n        // 如果是简单元素(没有被分解为单独节点)，直接应用翻译\n        if (!nodeTextMap.has(element)) {\n          this._applyTranslation(element, originalText, translatedText);\n          // 等待下一个微任务，确保DOM更新完成\n          queueMicrotask(() => {\n            element.classList.remove(this.config.pendingClass);\n            element.classList.add(this.config.doneClass);\n          });\n        } else {\n          // 已经单独处理了各个文本节点，只需标记为已翻译\n          // 等待下一个微任务，确保DOM更新完成\n          queueMicrotask(() => {\n            element.classList.remove(this.config.pendingClass);\n            element.classList.add(this.config.doneClass);\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * 获取元素文本内容\n   * @param {Element} element - 需要获取文本的元素\n   * @returns {string|null} - 元素的文本内容，如果没有有效文本则返回null\n   * @private\n   */\n  _getElementText(element) {\n    // 使用TreeWalker遍历元素的所有文本节点\n    let textContent = '';\n    const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, {\n      acceptNode: (node) => {\n        // 只获取直接的文本节点，跳过深层元素内的文本\n        if (node.parentNode !== element) {\n          return NodeFilter.FILTER_SKIP;\n        }\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    });\n\n    let node = treeWalker.nextNode();\n    while (node) {\n      const text = node.textContent.trim();\n      if (text) {\n        textContent += `${text} `;\n      }\n      node = treeWalker.nextNode();\n    }\n\n    textContent = textContent.trim();\n\n    // 如果是空文本，直接返回null\n    if (!textContent || /^\\s*$/.test(textContent)) {\n      return null;\n    }\n\n    // 过滤掉只包含数字、空格、回车、特殊字符的文本\n    // 但保留包含中文、英文、数字的文本\n    if (/^[\\s\\d!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~]+$/.test(textContent) && !/[a-zA-Z\\u4e00-\\u9fa5]/.test(textContent)) {\n      return null;\n    }\n\n    return textContent;\n  }\n\n  /**\n   * 应用翻译结果到元素\n   * @param {Element} element - 需要应用翻译的元素\n   * @param {string} originalText - 原始文本\n   * @param {string} translatedText - 翻译后的文本\n   * @private\n   */\n  _applyTranslation(element, originalText, translatedText) {\n    if (!translatedText || originalText === translatedText) {\n      return;\n    }\n\n    // 标记已翻译\n    element.classList.add(this.config.doneClass);\n\n    // 如果元素有子元素，只替换直接的文本节点\n    if (element.childElementCount > 0) {\n      // 1. 收集所有直接文本节点信息\n      const textNodes = this._getDirectTextNodes(element);\n\n      // 如果没有文本节点或只有一个文本节点，简单处理\n      if (textNodes.length === 0) {\n        return;\n      }\n      if (textNodes.length === 1) {\n        const {\n          node,\n          leadingSpaces,\n          trailingSpaces\n        } = textNodes[0];\n        node.textContent = leadingSpaces + translatedText + trailingSpaces;\n        return;\n      }\n\n      // 注意：多文本节点的情况已在_translateElementBatch中处理\n      // 这里作为备用方案，使用简单的按比例分配\n      const totalTextLength = textNodes.reduce((sum, item) => sum + item.text.length, 0);\n      let usedTranslationLength = 0;\n\n      textNodes.forEach((item, index) => {\n        const {\n          node,\n          text,\n          leadingSpaces,\n          trailingSpaces\n        } = item;\n        let nodeTranslation;\n\n        if (index === textNodes.length - 1) {\n          // 最后一个节点使用剩余的所有翻译文本\n          nodeTranslation = translatedText.substring(usedTranslationLength);\n        } else {\n          // 计算当前节点文本在原始完整文本中的占比\n          const ratio = text.length / totalTextLength;\n          // 根据比例计算应该分配的翻译文本长度\n          const translationLength = Math.round(translatedText.length * ratio);\n\n          // 从当前位置提取对应长度的翻译文本\n          nodeTranslation = translatedText.substring(usedTranslationLength, usedTranslationLength + translationLength);\n\n          // 更新已使用的翻译文本长度\n          usedTranslationLength += translationLength;\n        }\n\n        // 应用翻译结果到文本节点，保留原始空格\n        node.textContent = leadingSpaces + nodeTranslation + trailingSpaces;\n      });\n    } else {\n      // 如果没有子元素，保留原始文本中的空格\n      const leadingSpaces = element.textContent.match(/^\\s*/)[0];\n      const trailingSpaces = element.textContent.match(/\\s*$/)[0];\n      element.textContent = leadingSpaces + translatedText + trailingSpaces;\n    }\n  }\n\n  /**\n   * 销毁实例，释放资源\n   * @returns {Translator} - 当前实例，支持链式调用\n   */\n  destroy() {\n    // 停止DOM观察器\n    this.stopObserver();\n\n    // 清空待处理元素\n    this.pendingElements.clear();\n\n    // 关闭数据库连接\n    if (this.translationCache?.db) {\n      this.translationCache.db.close();\n      this.translationCache.db = null;\n    }\n\n    // 重置状态\n    this.isTranslating = false;\n\n    return this;\n  }\n}\n\nexport default Translator; "],"names":["DEFAULT_IGNORE_SELECTORS","DEFAULT_CONFIG","toLang","navigator","language","fromLang","ignore","force","doneClass","pendingClass","translateFn","translateText","manualDict","beforeTranslate","afterTranslate","TranslationCache","constructor","this","dbName","storeName","db","initPromise","_initDatabase","_generateHash","str","hash","i","length","charCodeAt","toString","Promise","resolve","reject","request","indexedDB","open","onupgradeneeded","event","target","result","objectStoreNames","contains","createObjectStore","keyPath","onsuccess","onerror","error","get","text","id","transaction","objectStore","value","set","translation","put","setBatch","texts","translations","all","map","index","clearTokenFromSession","sessionStorage","removeItem","async","getAuthToken","now","Date","token","timestamp","tokenData","getItem","JSON","parse","loadTokenFromSession","response","fetch","method","headers","ok","newToken","setItem","stringify","saveTokenToSession","filteredTexts","filter","trim","url","data","Text","Authorization","body","json","item","detectLang","Array","isArray","getSupportedLangs","displayLang","getBrowserLang","browserLang","to","Translator","config","langDict","term","Object","keys","standalone","case","observer","translationCache","Set","forceSelectorString","join","ignoreSelectorString","isTranslating","pendingElements","observerConfig","childList","subtree","characterData","_createNodeFilter","acceptNode","node","classList","NodeFilter","FILTER_SKIP","matches","FILTER_ACCEPT","parent","parentNode","document","hasForceChild","children","querySelector","FILTER_REJECT","bind","startObserver","root","disconnect","MutationObserver","mutations","shouldTranslate","mutation","type","addedNodes","nodeType","Node","ELEMENT_NODE","treeWalker","createTreeWalker","SHOW_ELEMENT","currentNode","nextNode","add","shouldSkip","_translatePending","observe","stopObserver","again","size","elements","from","clear","_translateElements","translatePage","wasObserving","rootElement","push","validElements","elementsText","el","_getElementText","batchElements","slice","batchTexts","_translateElementBatch","_splitByTerms","toLangDict","terms","sort","a","b","toLowerCase","containsAnyTerm","includes","parts","currentText","foundTerm","flags","match","RegExp","exec","substring","_getDirectTextNodes","element","textNodes","SHOW_TEXT","textContent","trimmed","leadingSpaces","trailingSpaces","textsArray","elementsWithText","textsToTranslate","nodeTextMap","Map","childElementCount","nodeInfo","isTextNode","validElementTexts","_","validTexts","termProcessedTexts","termMappings","part","uniqueTextsToTranslate","manualTranslations","textsToFetch","cachedTranslation","apiResults","forEach","finalTranslations","originalText","entries","translatedParts","has","translatedText","parentElement","queueMicrotask","remove","_applyTranslation","test","totalTextLength","reduce","sum","usedTranslationLength","nodeTranslation","ratio","translationLength","Math","round","destroy","close"],"mappings":"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"}